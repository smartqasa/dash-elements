import { x, y as formattedTime2, c as formattedDate, q as launchApp, u as navigateToArea, l as dialogPopup, s as dialogTable, E, h as createElement$1, o, i, _ as __decorate, r, a as r$1, g as getDeviceType, e as getDeviceOrientation, p as r$2, d as deviceRefresh, b as deviceReboot, j as createElements, m as loadYamlAsJson, n, t } from './navigate-to-area-CNRLwzgo.js';

function launchClock(e) {
    e.stopPropagation();
    launchApp('clock');
}
function renderHeader(headerChips) {
    const chips = headerChips ?? [];
    return x `
        <div class="header-container">
            <div class="header-time-date" @click="${launchClock}">
                <div class="time">${formattedTime2()}</div>
                <div class="date">${formattedDate()}</div>
            </div>
            <div class="header-chips">
                ${chips.map((chip) => x `<div class="chip">${chip}</div>`)}
            </div>
        </div>
    `;
}

function renderFooter() {
    function renderFooterButton(icon, name, action) {
        return x `
            <div
                class="footer-button"
                @click=${(e) => {
            e.stopPropagation();
            action();
        }}
            >
                <ha-icon icon=${icon}></ha-icon>
                <span>${name}</span>
            </div>
        `;
    }
    function handleHome() {
        const startArea = window.smartqasa.startArea;
        if (!startArea)
            return;
        const currentArea = new URL(location.href).pathname.split('/').pop();
        if (currentArea !== startArea) {
            navigateToArea(startArea);
        }
        else {
            navigateToArea('home');
        }
    }
    function handleAreas() {
        dialogPopup(dialogTable['areas'].data);
    }
    function handleMenu() {
        window.smartqasa.menuTab = 0;
        dialogPopup(dialogTable['menu'].data);
    }
    return x `
        <div class="footer-container">
            ${renderFooterButton('hass:home', 'Home', handleHome)}
            ${renderFooterButton('hass:view-dashboard', 'Areas', handleAreas)}
            ${renderFooterButton('hass:menu', 'Menu', handleMenu)}
        </div>
    `;
}

var img = "data:image/png;base64,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";

function renderArea(name, picture, chips, isPhone, isLandscape) {
    return x `
        <div class="area-container">
            <div class="area-name ${isPhone ? 'overlay' : ''}">${name}</div>
            <img
                class="area-picture"
                src="/local/smartqasa/custom/pictures/${picture}"
                alt="Area picture..."
                @error=${(e) => {
        try {
            const img$1 = e.target;
            img$1.src = img;
        }
        catch {
        }
        finally {
            e.preventDefault();
            e.stopPropagation();
        }
    }}
            />
            ${chips.length > 0
        ? x `<div class="area-chips">
                      ${chips.map((chip) => x `<div class="chip">${chip}</div>`)}
                  </div>`
        : E}
            ${isPhone && isLandscape
        ? x `<div class="footer-container">${renderFooter()}</div>`
        : E}
        </div>
    `;
}

/**
 * SSR Window 4.0.2
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: December 13, 2021
 */
/* eslint-disable no-param-reassign */
function isObject$2(obj) {
  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
}
function extend$2(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach(key => {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$2(src[key]) && isObject$2(target[key]) && Object.keys(src[key]).length > 0) {
      extend$2(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {},
  removeEventListener() {},
  activeElement: {
    blur() {},
    nodeName: ''
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {}
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  }
};
function getDocument() {
  const doc = typeof document !== 'undefined' ? document : {};
  extend$2(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ''
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  },
  history: {
    replaceState() {},
    pushState() {},
    go() {},
    back() {}
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener() {},
  removeEventListener() {},
  getComputedStyle() {
    return {
      getPropertyValue() {
        return '';
      }
    };
  },
  Image() {},
  Date() {},
  screen: {},
  setTimeout() {},
  clearTimeout() {},
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === 'undefined') {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === 'undefined') {
      return;
    }
    clearTimeout(id);
  }
};
function getWindow() {
  const win = typeof window !== 'undefined' ? window : {};
  extend$2(win, ssrWindow);
  return win;
}

function classesToTokens(classes) {
  if (classes === void 0) {
    classes = '';
  }
  return classes.trim().split(' ').filter(c => !!c.trim());
}

function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach(key => {
    try {
      object[key] = null;
    } catch (e) {
      // no getter for object
    }
    try {
      delete object[key];
    } catch (e) {
      // something got wrong
    }
  });
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(el) {
  const window = getWindow();
  let style;
  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }
  const window = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el);
  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
    }
    // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case
    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }
  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }
  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject$1(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}
function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend$1() {
  const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  for (let i = 1; i < arguments.length; i += 1) {
    const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) {
          if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
  let {
    swiper,
    targetPosition,
    side
  } = _ref;
  const window = getWindow();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = 'none';
  window.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? 'next' : 'prev';
  const isOutOfBound = (current, target) => {
    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
  };
  const animate = () => {
    time = new Date().getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.scrollSnapType = '';
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
  };
  animate();
}
function getSlideTransformEl(slideEl) {
  return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;
}
function elementChildren(element, selector) {
  if (selector === void 0) {
    selector = '';
  }
  const children = [...element.children];
  if (element instanceof HTMLSlotElement) {
    children.push(...element.assignedElements());
  }
  if (!selector) {
    return children;
  }
  return children.filter(el => el.matches(selector));
}
function elementIsChildOf(el, parent) {
  const isChild = parent.contains(el);
  if (!isChild && parent instanceof HTMLSlotElement) {
    const children = [...parent.assignedElements()];
    return children.includes(el);
  }
  return isChild;
}
function showWarning(text) {
  try {
    console.warn(text);
    return;
  } catch (err) {
    // err
  }
}
function createElement(tag, classes) {
  if (classes === void 0) {
    classes = [];
  }
  const el = document.createElement(tag);
  el.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));
  return el;
}
function elementOffset(el) {
  const window = getWindow();
  const document = getDocument();
  const box = el.getBoundingClientRect();
  const body = document.body;
  const clientTop = el.clientTop || body.clientTop || 0;
  const clientLeft = el.clientLeft || body.clientLeft || 0;
  const scrollTop = el === window ? window.scrollY : el.scrollTop;
  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
  return {
    top: box.top + scrollTop - clientTop,
    left: box.left + scrollLeft - clientLeft
  };
}
function elementPrevAll(el, selector) {
  const prevEls = [];
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if (prev.matches(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return prevEls;
}
function elementNextAll(el, selector) {
  const nextEls = [];
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if (next.matches(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  const window = getWindow();
  return window.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
  let child = el;
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
function elementParents(el, selector) {
  const parents = []; // eslint-disable-line
  let parent = el.parentElement; // eslint-disable-line
  while (parent) {
    if (selector) {
      if (parent.matches(selector)) parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementTransitionEnd(el, callback) {
  function fireCallBack(e) {
    if (e.target !== el) return;
    callback.call(el, e);
    el.removeEventListener('transitionend', fireCallBack);
  }
  if (callback) {
    el.addEventListener('transitionend', fireCallBack);
  }
}
function elementOuterSize(el, size, includeMargins) {
  const window = getWindow();
  {
    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
  }
}
function makeElementsArray(el) {
  return (Array.isArray(el) ? el : [el]).filter(e => !!e);
}
function getRotateFix(swiper) {
  return v => {
    if (Math.abs(v) > 0 && swiper.browser && swiper.browser.need3dFix && Math.abs(v) % 90 === 0) {
      return v + 0.001;
    }
    return v;
  };
}

let support;
function calcSupport() {
  const window = getWindow();
  const document = getDocument();
  return {
    smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}

let deviceCached;
function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support = getSupport();
  const window = getWindow();
  const platform = window.navigator.platform;
  const ua = userAgent || window.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === 'Win32';
  let macos = platform === 'MacIntel';

  // iPadOs 13 fix
  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  }

  // Android
  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }

  // Export object
  return device;
}
function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}

let browser;
function calcBrowser() {
  const window = getWindow();
  const device = getDevice();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }
  if (isSafari()) {
    const ua = String(window.navigator.userAgent);
    if (ua.includes('Version/')) {
      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
  const isSafariBrowser = isSafari();
  const need3dFix = isSafariBrowser || isWebView && device.ios;
  return {
    isSafari: needPerspectiveFix || isSafariBrowser,
    needPerspectiveFix,
    need3dFix,
    isWebView
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}

function Resize(_ref) {
  let {
    swiper,
    on,
    emit
  } = _ref;
  const window = getWindow();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('beforeResize');
    emit('resize');
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver(entries => {
      animationFrame = window.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(_ref2 => {
          let {
            contentBoxSize,
            contentRect,
            target
          } = _ref2;
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('orientationchange');
  };
  on('init', () => {
    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
      createObserver();
      return;
    }
    window.addEventListener('resize', resizeHandler);
    window.addEventListener('orientationchange', orientationChangeHandler);
  });
  on('destroy', () => {
    removeObserver();
    window.removeEventListener('resize', resizeHandler);
    window.removeEventListener('orientationchange', orientationChangeHandler);
  });
}

function Observer(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const observers = [];
  const window = getWindow();
  const attach = function (target, options) {
    if (options === void 0) {
      options = {};
    }
    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    const observer = new ObserverFunc(mutations => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (swiper.__preventObserver__) return;
      if (mutations.length === 1) {
        emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        emit('observerUpdate', mutations[0]);
      };
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: swiper.isElement || (typeof options.childList === 'undefined' ? true : options).childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = elementParents(swiper.hostEl);
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    // Observe container
    attach(swiper.hostEl, {
      childList: swiper.params.observeSlideChildren
    });

    // Observe wrapper
    attach(swiper.wrapperEl, {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach(observer => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on('init', init);
  on('destroy', destroy);
}

/* eslint-disable no-underscore-dangle */

var eventsEmitter = {
  on(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(event => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    function onceHandler() {
      self.off(events, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self, args);
    }
    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }
    return self;
  },
  offAny(handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsAnyListeners) return self;
    const index = self.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }
    return self;
  },
  off(events, handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(event => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit() {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(event => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(eventHandler => {
          eventHandler.apply(context, [event, ...data]);
        });
      }
      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(eventHandler => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
};

function updateSize() {
  const swiper = this;
  let width;
  let height;
  const el = swiper.el;
  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = el.clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = el.clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }

  // Subtract paddings
  width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);
  height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}

function updateSlides() {
  const swiper = this;
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper.virtualSize = -spaceBetween;

  // reset margins
  slides.forEach(slideEl => {
    if (rtl) {
      slideEl.style.marginLeft = '';
    } else {
      slideEl.style.marginRight = '';
    }
    slideEl.style.marginBottom = '';
    slideEl.style.marginTop = '';
  });

  // reset cssMode offsets
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');
    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slides);
  } else if (swiper.grid) {
    swiper.grid.unsetSlides();
  }

  // Calc slides
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    let slide;
    if (slides[i]) slide = slides[i];
    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide, slides);
    }
    if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      if (shouldResetSlideSize) {
        slides[i].style[swiper.getDirectionLabel('width')] = ``;
      }
      const slideStyles = getComputedStyle(slide);
      const currentTransform = slide.style.transform;
      const currentWebKitTransform = slide.style.webkitTransform;
      if (currentTransform) {
        slide.style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width') : elementOuterSize(slide, 'height');
      } else {
        // eslint-disable-next-line
        const width = getDirectionPropertyValue(slideStyles, 'width');
        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        const boxSizing = slideStyles.getPropertyValue('box-sizing');
        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[swiper.getDirectionLabel('width')] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid);
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i = 0; i < groups; i += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper.virtualSize += size;
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');
    slides.filter((_, slideIndex) => {
      if (!params.cssMode || params.loop) return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach(slideEl => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
    snapGrid = snapGrid.map(snap => {
      if (snap <= 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
    if (allSlidesSize + offsetSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  swiper.emit('slidesUpdated');
  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.el.classList.remove(backFaceHiddenClass);
    }
  }
}

function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = index => {
    if (isVirtual) {
      return swiper.slides[swiper.getSlideIndexByData(index)];
    }
    return swiper.slides[index];
  };
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || []).forEach(slide => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
}

function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  // eslint-disable-next-line
  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
  }
}

const toggleSlideClasses$1 = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    let slideOffset = slide.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide);
      swiper.visibleSlidesIndexes.push(i);
    }
    toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);
    toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);
    slide.progress = rtl ? -slideProgress : slideProgress;
    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}

function updateProgress(translate) {
  const swiper = this;
  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    // eslint-disable-next-line
    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded) progress = 0;
    if (isEndRounded) progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper.getSlideIndexByData(0);
    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1) progressLoop -= 1;
  }
  Object.assign(swiper, {
    progress,
    progressLoop,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }
  swiper.emit('progress', progress);
}

const toggleSlideClasses = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const getFilteredSlide = selector => {
    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  };
  let activeSlide;
  let prevSlide;
  let nextSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    if (gridEnabled) {
      activeSlide = slides.filter(slideEl => slideEl.column === activeIndex)[0];
      nextSlide = slides.filter(slideEl => slideEl.column === activeIndex + 1)[0];
      prevSlide = slides.filter(slideEl => slideEl.column === activeIndex - 1)[0];
    } else {
      activeSlide = slides[activeIndex];
    }
  }
  if (activeSlide) {
    if (!gridEnabled) {
      // Next Slide
      nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !nextSlide) {
        nextSlide = slides[0];
      }

      // Prev Slide
      prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !prevSlide === 0) {
        prevSlide = slides[slides.length - 1];
      }
    }
  }
  slides.forEach(slideEl => {
    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
  });
  swiper.emitSlidesClasses();
}

const processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
    if (!lazyEl && swiper.isElement) {
      if (slideEl.shadowRoot) {
        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      } else {
        // init later
        requestAnimationFrame(() => {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
            if (lazyEl) lazyEl.remove();
          }
        });
      }
    }
    if (lazyEl) lazyEl.remove();
  }
};
const unlazy = (swiper, index) => {
  if (!swiper.slides[index]) return;
  const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
  if (imageEl) imageEl.removeAttribute('loading');
};
const preload = swiper => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  let amount = swiper.params.lazyPreloadPrevNext;
  const len = swiper.slides.length;
  if (!len || !amount || amount < 0) return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
  const activeIndex = swiper.activeIndex;
  if (swiper.params.grid && swiper.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount
    }).map((_, i) => {
      return activeColumn + slidesPerView + i;
    }));
    swiper.slides.forEach((slideEl, i) => {
      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind || swiper.params.loop) {
    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
      const realIndex = (i % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
    }
  } else {
    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
        unlazy(swiper, i);
      }
    }
  }
};

function getActiveIndexByTranslate(swiper) {
  const {
    slidesGrid,
    params
  } = swiper;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  let activeIndex;
  for (let i = 0; i < slidesGrid.length; i += 1) {
    if (typeof slidesGrid[i + 1] !== 'undefined') {
      if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
        activeIndex = i;
      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
        activeIndex = i + 1;
      }
    } else if (translate >= slidesGrid[i]) {
      activeIndex = i;
    }
  }
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = aIndex => {
    let realIndex = aIndex - swiper.virtual.slidesBefore;
    if (realIndex < 0) {
      realIndex = swiper.virtual.slides.length + realIndex;
    }
    if (realIndex >= swiper.virtual.slides.length) {
      realIndex -= swiper.virtual.slides.length;
    }
    return realIndex;
  };
  if (typeof activeIndex === 'undefined') {
    activeIndex = getActiveIndexByTranslate(swiper);
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex && !swiper.params.loop) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }
  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
    swiper.realIndex = getVirtualRealIndex(activeIndex);
    return;
  }
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;

  // Get real index
  let realIndex;
  if (swiper.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (gridEnabled) {
    const firstSlideInColumn = swiper.slides.filter(slideEl => slideEl.column === activeIndex)[0];
    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);
    if (Number.isNaN(activeSlideIndex)) {
      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
    }
    realIndex = Math.floor(activeSlideIndex / params.grid.rows);
  } else if (swiper.slides[activeIndex]) {
    const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');
    if (slideIndex) {
      realIndex = parseInt(slideIndex, 10);
    } else {
      realIndex = activeIndex;
    }
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper.initialized) {
    preload(swiper);
  }
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }
    swiper.emit('slideChange');
  }
}

function updateClickedSlide(el, path) {
  const swiper = this;
  const params = swiper.params;
  let slide = el.closest(`.${params.slideClass}, swiper-slide`);
  if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {
    [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {
      if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
        slide = pathEl;
      }
    });
  }
  let slideFound = false;
  let slideIndex;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};

function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? 'x' : 'y';
  }
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate,
    wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }
  let currentTranslate = getTranslate(wrapperEl, axis);
  currentTranslate += swiper.cssOverflowAdjustment();
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

function setTranslate(translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;
  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    if (swiper.isHorizontal()) {
      x -= swiper.cssOverflowAdjustment();
    } else {
      y -= swiper.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
  }

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }
  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate() {
  return -this.snapGrid[0];
}

function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;

  // Update progress
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: -newTranslate,
        behavior: 'smooth'
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          swiper.animating = false;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}

var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};

function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
    swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';
  }
  swiper.emit('setTransition', duration, byController);
}

function transitionEmit(_ref) {
  let {
    swiper,
    runCallbacks,
    direction,
    step
  } = _ref;
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === 'next') {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}

function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'Start'
  });
}

function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'End'
  });
}

var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};

function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    index = parseInt(index, 10);
  }
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  const translate = -snapGrid[snapIndex];
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  // Update progress
  swiper.updateProgress(translate);
  let direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

  // initial virtual
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  const isInitialVirtual = isVirtual && initial;
  // Update Index
  if (!isInitialVirtual && (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate : -translate;
    if (speed === 0) {
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = 'none';
        swiper._immediateVirtual = true;
      }
      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
        swiper._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = '';
          swiper._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: t,
        behavior: 'smooth'
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit('beforeTransitionStart', speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
        if (!swiper || swiper.destroyed) return;
        if (e.target !== this) return;
        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}

function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
  let newIndex = index;
  if (swiper.params.loop) {
    if (swiper.virtual && swiper.params.virtual.enabled) {
      // eslint-disable-next-line
      newIndex = newIndex + swiper.virtual.slidesBefore;
    } else {
      let targetSlideIndex;
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        targetSlideIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        targetSlideIndex = swiper.getSlideIndexByData(newIndex);
      }
      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
      const {
        centeredSlides
      } = swiper.params;
      let slidesPerView = swiper.params.slidesPerView;
      if (slidesPerView === 'auto') {
        slidesPerView = swiper.slidesPerViewDynamic();
      } else {
        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
        if (centeredSlides && slidesPerView % 2 === 0) {
          slidesPerView = slidesPerView + 1;
        }
      }
      let needLoopFix = cols - targetSlideIndex < slidesPerView;
      if (centeredSlides) {
        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
      }
      if (internal && centeredSlides && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {
        needLoopFix = false;
      }
      if (needLoopFix) {
        const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';
        swiper.loopFix({
          direction,
          slideTo: true,
          activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
          slideRealIndex: direction === 'next' ? swiper.realIndex : undefined
        });
      }
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        newIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        newIndex = swiper.getSlideIndexByData(newIndex);
      }
    }
  }
  requestAnimationFrame(() => {
    swiper.slideTo(newIndex, speed, runCallbacks, internal);
  });
  return swiper;
}

/* eslint no-unused-vars: "off" */
function slideNext(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    enabled,
    params,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'next'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
      });
      return true;
    }
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'prev'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        // prevSnap = snap;
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== 'undefined') {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
    requestAnimationFrame(() => {
      swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    });
    return true;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide() {
  const swiper = this;
  if (swiper.destroyed) return;
  const {
    params,
    slidesEl
  } = swiper;
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};

function loopCreate(slideRealIndex) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  const initSlides = () => {
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    slides.forEach((el, index) => {
      el.setAttribute('data-swiper-slide-index', index);
    });
  };
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
  const addBlankSlides = amountOfSlides => {
    for (let i = 0; i < amountOfSlides; i += 1) {
      const slideEl = swiper.isElement ? createElement('swiper-slide', [params.slideBlankClass]) : createElement('div', [params.slideClass, params.slideBlankClass]);
      swiper.slidesEl.append(slideEl);
    }
  };
  if (shouldFillGroup) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else if (shouldFillGrid) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else {
    initSlides();
  }
  swiper.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? undefined : 'next'
  });
}

function loopFix(_temp) {
  let {
    slideRealIndex,
    slideTo = true,
    direction,
    setTranslate,
    activeSlideIndex,
    byController,
    byMousewheel
  } = _temp === void 0 ? {} : _temp;
  const swiper = this;
  if (!swiper.params.loop) return;
  swiper.emit('beforeLoopFix');
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper;
  const {
    centeredSlides
  } = params;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  if (swiper.virtual && params.virtual.enabled) {
    if (slideTo) {
      if (!params.centeredSlides && swiper.snapIndex === 0) {
        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
    return;
  }
  let slidesPerView = params.slidesPerView;
  if (slidesPerView === 'auto') {
    slidesPerView = swiper.slidesPerViewDynamic();
  } else {
    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
    if (centeredSlides && slidesPerView % 2 === 0) {
      slidesPerView = slidesPerView + 1;
    }
  }
  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
  let loopedSlides = slidesPerGroup;
  if (loopedSlides % slidesPerGroup !== 0) {
    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
  }
  loopedSlides += params.loopAdditionalSlides;
  swiper.loopedSlides = loopedSlides;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  if (slides.length < slidesPerView + loopedSlides) {
    showWarning('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');
  } else if (gridEnabled && params.grid.fill === 'row') {
    showWarning('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');
  }
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  let activeIndex = swiper.activeIndex;
  if (typeof activeSlideIndex === 'undefined') {
    activeSlideIndex = swiper.getSlideIndex(slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === 'next' || !direction;
  const isPrev = direction === 'prev' || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
  const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);
  // prepend last slides before start
  if (activeColIndexWithShift < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        const colIndexToPrepend = cols - index - 1;
        for (let i = slides.length - 1; i >= 0; i -= 1) {
          if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
        }
        // slides.forEach((slide, slideIndex) => {
        //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);
        // });
      } else {
        prependSlidesIndexes.push(cols - index - 1);
      }
    }
  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
    for (let i = 0; i < slidesAppended; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        slides.forEach((slide, slideIndex) => {
          if (slide.column === index) appendSlidesIndexes.push(slideIndex);
        });
      } else {
        appendSlidesIndexes.push(index);
      }
    }
  }
  swiper.__preventObserver__ = true;
  requestAnimationFrame(() => {
    swiper.__preventObserver__ = false;
  });
  if (isPrev) {
    prependSlidesIndexes.forEach(index => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach(index => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper.recalcSlides();
  if (params.slidesPerView === 'auto') {
    swiper.updateSlides();
  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
    swiper.slides.forEach((slide, slideIndex) => {
      swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
    });
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (slideTo) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
          if (setTranslate) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        if (setTranslate) {
          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
          swiper.touchEventsData.currentTranslate = swiper.translate;
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
      }
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.controller && swiper.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      direction,
      setTranslate,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper.controller.control)) {
      swiper.controller.control.forEach(c => {
        if (!c.destroyed && c.params.loop) c.loopFix({
          ...loopParams,
          slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
        });
      });
    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
      swiper.controller.control.loopFix({
        ...loopParams,
        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
      });
    }
  }
  swiper.emit('loopFix');
}

function loopDestroy() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  swiper.recalcSlides();
  const newSlidesOrder = [];
  swiper.slides.forEach(slideEl => {
    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper.slides.forEach(slideEl => {
    slideEl.removeAttribute('data-swiper-slide-index');
  });
  newSlidesOrder.forEach(slideEl => {
    slidesEl.append(slideEl);
  });
  swiper.recalcSlides();
  swiper.slideTo(swiper.realIndex, 0);
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};

function setGrabCursor(moving) {
  const swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  el.style.cursor = 'move';
  el.style.cursor = moving ? 'grabbing' : 'grab';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}

function unsetGrabCursor() {
  const swiper = this;
  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};

// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function preventEdgeSwipe(swiper, event, startX) {
  const window = getWindow();
  const {
    params
  } = swiper;
  const edgeSwipeDetection = params.edgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
      return true;
    }
    return false;
  }
  return true;
}
function onTouchStart(event) {
  const swiper = this;
  const document = getDocument();
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  const data = swiper.touchEventsData;
  if (e.type === 'pointerdown') {
    if (data.pointerId !== null && data.pointerId !== e.pointerId) {
      return;
    }
    data.pointerId = e.pointerId;
  } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {
    data.touchId = e.targetTouches[0].identifier;
  }
  if (e.type === 'touchstart') {
    // don't proceed touch event
    preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
    return;
  }
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === 'mouse') return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let targetEl = e.target;
  if (params.touchEventsTarget === 'wrapper') {
    if (!elementIsChildOf(targetEl, swiper.wrapperEl)) return;
  }
  if ('which' in e && e.which === 3) return;
  if ('button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;

  // change target el for shadow root component
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
  // eslint-disable-next-line
  const eventPath = e.composedPath ? e.composedPath() : e.path;
  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot);

  // use closestElement for shadow root element to get the actual closest for nested shadow root element
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler)) return;
  }
  touches.currentX = e.pageX;
  touches.currentY = e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  if (!preventEdgeSwipe(swiper, e, startX)) {
    return;
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === 'SELECT') {
      data.isTouched = false;
    }
  }
  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl && (e.pointerType === 'mouse' || e.pointerType !== 'mouse' && !targetEl.matches(data.focusableElements))) {
    document.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit('touchStart', e);
}

function onTouchMove(event) {
  const document = getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && event.pointerType === 'mouse') return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (e.type === 'pointermove') {
    if (data.touchId !== null) return; // return from pointer if we use touch
    const id = e.pointerId;
    if (id !== data.pointerId) return;
  }
  let targetTouch;
  if (e.type === 'touchmove') {
    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  } else {
    targetTouch = e;
  }
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!e.target.matches(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== e.target && e.pointerType !== 'mouse') {
    document.activeElement.blur();
  }
  if (document.activeElement) {
    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  touches.previousX = touches.currentX;
  touches.previousY = touches.currentY;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  let diff = swiper.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
  const isLoop = swiper.params.loop && !params.cssMode;
  const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;
  if (!data.isMoved) {
    if (isLoop && allowLoopFix) {
      swiper.loopFix({
        direction: swiper.swipeDirection
      });
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      const evt = new window.CustomEvent('transitionend', {
        bubbles: true,
        cancelable: true,
        detail: {
          bySwiperTouchMove: true
        }
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  let loopFixed;
  new Date().getTime();
  if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
    Object.assign(touches, {
      startX: pageX,
      startY: pageY,
      currentX: pageX,
      currentY: pageY,
      startTranslate: data.currentTranslate
    });
    data.loopSwapReset = true;
    data.startTranslate = data.currentTranslate;
    return;
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
      swiper.loopFix({
        direction: 'prev',
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
      swiper.loopFix({
        direction: 'next',
        setTranslate: true,
        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }

  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode) return;

  // Update active index in free mode
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  let targetTouch;
  const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';
  if (!isTouchEvent) {
    if (data.touchId !== null) return; // return from pointer if we use touch
    if (e.pointerId !== data.pointerId) return;
    targetTouch = e;
  } else {
    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  }
  if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {
    const proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  data.pointerId = null;
  data.touchId = null;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === 'mouse') return;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = now();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }
  data.lastClickTime = now();
  nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }

  // Find current slide
  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (swipeToLast || currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    if (swiper.params.loop && !isVirtual) {
      swiper.slideToLoop(swiper.realIndex, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    clearTimeout(swiper.autoplay.resizeTimeout);
    swiper.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.resume();
      }
    }, 500);
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick(e) {
  const swiper = this;
  if (!swiper.enabled) return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  // eslint-disable-next-line
  if (swiper.translate === 0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit('setTranslate', swiper.translate, false);
}

function onLoad(e) {
  const swiper = this;
  processLazyPreloader(swiper, e.target);
  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
    return;
  }
  swiper.update();
}

function onDocumentTouchStart() {
  const swiper = this;
  if (swiper.documentTouchHandlerProceeded) return;
  swiper.documentTouchHandlerProceeded = true;
  if (swiper.params.touchReleaseOnEdges) {
    swiper.el.style.touchAction = 'auto';
  }
}

const events = (swiper, method) => {
  const document = getDocument();
  const {
    params,
    el,
    wrapperEl,
    device
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
  const swiperMethod = method;
  if (!el || typeof el === 'string') return;

  // Touch Events
  document[domMethod]('touchstart', swiper.onDocumentTouchStart, {
    passive: false,
    capture
  });
  el[domMethod]('touchstart', swiper.onTouchStart, {
    passive: false
  });
  el[domMethod]('pointerdown', swiper.onTouchStart, {
    passive: false
  });
  document[domMethod]('touchmove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('pointermove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('touchend', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerup', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointercancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('touchcancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerout', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerleave', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('contextmenu', swiper.onTouchEnd, {
    passive: true
  });

  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]('scroll', swiper.onScroll);
  }

  // Resize handler
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper[swiperMethod]('observerUpdate', onResize, true);
  }

  // Images loader
  el[domMethod]('load', swiper.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  swiper.onLoad = onLoad.bind(swiper);
  events(swiper, 'on');
}
function detachEvents() {
  const swiper = this;
  events(swiper, 'off');
}
var events$1 = {
  attachEvents,
  detachEvents
};

const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    realIndex,
    initialized,
    params,
    el
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;

  // Get breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasGrabCursor = swiper.params.grabCursor;
  const isGrabCursor = breakpointParams.grabCursor;
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
      el.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  if (wasGrabCursor && !isGrabCursor) {
    swiper.unsetGrabCursor();
  } else if (!wasGrabCursor && isGrabCursor) {
    swiper.setGrabCursor();
  }

  // Toggle navigation, pagination, scrollbar
  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
    if (typeof breakpointParams[prop] === 'undefined') return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  const wasLoop = params.loop;
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  extend$1(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  const hasLoop = swiper.params.loop;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);
  if (initialized) {
    if (needsReLoop) {
      swiper.loopDestroy();
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (!wasLoop && hasLoop) {
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (wasLoop && !hasLoop) {
      swiper.loopDestroy();
    }
  }
  swiper.emit('breakpoint', breakpointParams);
}

function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = 'window';
  }
  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  let breakpoint = false;
  const window = getWindow();
  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints).map(point => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value
    } = points[i];
    if (base === 'window') {
      if (window.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var breakpoints = {
  setBreakpoint,
  getBreakpoint
};

function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach(item => {
    if (typeof item === 'object') {
      Object.keys(item).forEach(classNames => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    el,
    device
  } = swiper;
  // prettier-ignore
  const suffixes = prepareClasses(['initialized', params.direction, {
    'free-mode': swiper.params.freeMode && params.freeMode.enabled
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'grid': params.grid && params.grid.rows > 1
  }, {
    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }, {
    'centered': params.cssMode && params.centeredSlides
  }, {
    'watch-progress': params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el.classList.add(...classNames);
  swiper.emitContainerClasses();
}

function removeClasses() {
  const swiper = this;
  const {
    el,
    classNames
  } = swiper;
  if (!el || typeof el === 'string') return;
  el.classList.remove(...classNames);
  swiper.emitContainerClasses();
}

var classes = {
  addClasses,
  removeClasses
};

function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
  }
}
var checkOverflow$1 = {
  checkOverflow
};

var defaults = {
  init: true,
  direction: 'horizontal',
  oneWayMovement: false,
  swiperElementNodeName: 'SWIPER-CONTAINER',
  touchEventsTarget: 'wrapper',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  eventsPrefix: 'swiper',
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopAddBlankSlides: true,
  loopAdditionalSlides: 0,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: 'swiper-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-blank',
  slideActiveClass: 'swiper-slide-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideFullyVisibleClass: 'swiper-slide-fully-visible',
  slideNextClass: 'swiper-slide-next',
  slidePrevClass: 'swiper-slide-prev',
  wrapperClass: 'swiper-wrapper',
  lazyPreloaderClass: 'swiper-lazy-preloader',
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};

function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== 'object' || moduleParams === null) {
      extend$1(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
      params[moduleParamName].auto = true;
    }
    if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
      params[moduleParamName].auto = true;
    }
    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
      extend$1(allModulesParams, obj);
      return;
    }
    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    extend$1(allModulesParams, obj);
  };
}

/* eslint no-param-reassign: "off" */
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
};
const extendedDefaults = {};
class Swiper {
  constructor() {
    let el;
    let params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};
    params = extend$1({}, params);
    if (el && !params.el) params.el = el;
    const document = getDocument();
    if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document.querySelectorAll(params.el).forEach(containerEl => {
        const newParams = extend$1({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      // eslint-disable-next-line no-constructor-return
      return swipers;
    }

    // Swiper Instance
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach(mod => {
      mod({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });

    // Extend defaults with modules params
    const swiperParams = extend$1({}, defaults, allModulesParams);

    // Extend defaults with passed params
    swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend$1({}, swiper.params);
    swiper.passedParams = extend$1({}, params);

    // add event listeners
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(eventName => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }

    // Extend Swiper
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        // Returns 0 unless `translate` is > 2**23
        // Should be subtracted from css values to prevent overflow
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        startMoving: undefined,
        pointerId: null,
        touchId: null
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit('_swiper');

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    // eslint-disable-next-line no-constructor-return
    return swiper;
  }
  getDirectionLabel(property) {
    if (this.isHorizontal()) {
      return property;
    }
    // prettier-ignore
    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = elementIndex(slides[0]);
    return elementIndex(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);
  }
  recalcSlides() {
    const swiper = this;
    const {
      slidesEl,
      params
    } = swiper;
    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit('enable');
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit('disable');
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(' ').filter(className => {
      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', cls.join(' '));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed) return '';
    return slideEl.className.split(' ').filter(className => {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.forEach(slideEl => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  }
  slidesPerViewDynamic(view, exact) {
    if (view === void 0) {
      view = 'current';
    }
    if (exact === void 0) {
      exact = false;
    }
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (typeof params.slidesPerView === 'number') return params.slidesPerView;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += Math.ceil(slides[i].swiperSlideSize);
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      // eslint-disable-next-line
      if (view === 'current') {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        // previous
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      }
    });
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate();
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
        translated = swiper.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }
  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }
    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.forEach(slideEl => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  }
  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
    swiper.rtl = direction === 'rtl';
    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
    if (swiper.rtl) {
      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'rtl';
    } else {
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'ltr';
    }
    swiper.update();
  }
  mount(element) {
    const swiper = this;
    if (swiper.mounted) return true;

    // Find el
    let el = element || swiper.params.el;
    if (typeof el === 'string') {
      el = document.querySelector(el);
    }
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
      swiper.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = el.shadowRoot.querySelector(getWrapperSelector());
        // Children needs to return slot items
        return res;
      }
      return elementChildren(el, getWrapperSelector())[0];
    };
    // Find Wrapper
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper.params.createElements) {
      wrapperEl = createElement('div', swiper.params.wrapperClass);
      el.append(wrapperEl);
      elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      el,
      wrapperEl,
      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
      hostEl: swiper.isElement ? el.parentNode.host : el,
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),
      wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    // Slide To Initial Slide
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Attach events
    swiper.attachEvents();
    const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
    if (swiper.isElement) {
      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
    }
    lazyElements.forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      } else {
        imageEl.addEventListener('load', e => {
          processLazyPreloader(swiper, e.target);
        });
      }
    });
    preload(swiper);

    // Init Flag
    swiper.initialized = true;
    preload(swiper);

    // Emit
    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  }
  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    const swiper = this;
    const {
      params,
      el,
      wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }
    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      if (el && typeof el !== 'string') {
        el.removeAttribute('style');
      }
      if (wrapperEl) {
        wrapperEl.removeAttribute('style');
      }
      if (slides && slides.length) {
        slides.forEach(slideEl => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute('style');
          slideEl.removeAttribute('data-swiper-slide-index');
        });
      }
    }
    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach(eventName => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      if (swiper.el && typeof swiper.el !== 'string') {
        swiper.el.swiper = null;
      }
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend$1(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach(m => Swiper.installModule(m));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
}
Object.keys(prototypes).forEach(prototypeGroup => {
  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer]);

function Virtual(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  extendParams({
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let cssModeTimeout;
  const document = getDocument();
  swiper.virtual = {
    cache: {},
    from: undefined,
    to: undefined,
    slides: [],
    offset: 0,
    slidesGrid: []
  };
  const tempDOM = document.createElement('div');
  function renderSlide(slide, index) {
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    // eslint-disable-next-line
    let slideEl;
    if (params.renderSlide) {
      slideEl = params.renderSlide.call(swiper, slide, index);
      if (typeof slideEl === 'string') {
        tempDOM.innerHTML = slideEl;
        slideEl = tempDOM.children[0];
      }
    } else if (swiper.isElement) {
      slideEl = createElement('swiper-slide');
    } else {
      slideEl = createElement('div', swiper.params.slideClass);
    }
    slideEl.setAttribute('data-swiper-slide-index', index);
    if (!params.renderSlide) {
      slideEl.innerHTML = slide;
    }
    if (params.cache) {
      swiper.virtual.cache[index] = slideEl;
    }
    return slideEl;
  }
  function update(force, beforeInit) {
    const {
      slidesPerView,
      slidesPerGroup,
      centeredSlides,
      loop: isLoop,
      initialSlide
    } = swiper.params;
    if (beforeInit && !isLoop && initialSlide > 0) {
      return;
    }
    const {
      addSlidesBefore,
      addSlidesAfter
    } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      offset: previousOffset
    } = swiper.virtual;
    if (!swiper.params.cssMode) {
      swiper.updateActiveIndex();
    }
    const activeIndex = swiper.activeIndex || 0;
    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;
    }
    let from = activeIndex - slidesBefore;
    let to = activeIndex + slidesAfter;
    if (!isLoop) {
      from = Math.max(from, 0);
      to = Math.min(to, slides.length - 1);
    }
    let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    if (isLoop && activeIndex >= slidesBefore) {
      from -= slidesBefore;
      if (!centeredSlides) offset += swiper.slidesGrid[0];
    } else if (isLoop && activeIndex < slidesBefore) {
      from = -slidesBefore;
      if (centeredSlides) offset += swiper.slidesGrid[0];
    }
    Object.assign(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid,
      slidesBefore,
      slidesAfter
    });
    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      emit('virtualUpdate');
    }
    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.forEach(slideEl => {
          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
        });
      }
      swiper.updateProgress();
      emit('virtualUpdate');
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()
      });
      if (swiper.params.virtual.renderExternalUpdate) {
        onRendered();
      } else {
        emit('virtualUpdate');
      }
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    const getSlideIndex = index => {
      let slideIndex = index;
      if (index < 0) {
        slideIndex = slides.length + index;
      } else if (slideIndex >= slides.length) {
        // eslint-disable-next-line
        slideIndex = slideIndex - slides.length;
      }
      return slideIndex;
    };
    if (force) {
      swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach(slideEl => {
        slideEl.remove();
      });
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          const slideIndex = getSlideIndex(i);
          swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`)).forEach(slideEl => {
            slideEl.remove();
          });
        }
      }
    }
    const loopFrom = isLoop ? -slides.length : 0;
    const loopTo = isLoop ? slides.length * 2 : slides.length;
    for (let i = loopFrom; i < loopTo; i += 1) {
      if (i >= from && i <= to) {
        const slideIndex = getSlideIndex(i);
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(slideIndex);
        } else {
          if (i > previousTo) appendIndexes.push(slideIndex);
          if (i < previousFrom) prependIndexes.push(slideIndex);
        }
      }
    }
    appendIndexes.forEach(index => {
      swiper.slidesEl.append(renderSlide(slides[index], index));
    });
    if (isLoop) {
      for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {
        const index = prependIndexes[i];
        swiper.slidesEl.prepend(renderSlide(slides[index], index));
      }
    } else {
      prependIndexes.sort((a, b) => b - a);
      prependIndexes.forEach(index => {
        swiper.slidesEl.prepend(renderSlide(slides[index], index));
      });
    }
    elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {
      slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
    });
    onRendered();
  }
  function appendSlide(slides) {
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    update(true);
  }
  function prependSlide(slides) {
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;
    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach(cachedIndex => {
        const cachedEl = cache[cachedIndex];
        const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');
        if (cachedElIndex) {
          cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
        }
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;
      });
      swiper.virtual.cache = newCache;
    }
    update(true);
    swiper.slideTo(newActiveIndex, 0);
  }
  function removeSlide(slidesIndexes) {
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
          // shift cache indexes
          Object.keys(swiper.virtual.cache).forEach(key => {
            if (key > slidesIndexes) {
              swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
              swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);
              delete swiper.virtual.cache[key];
            }
          });
        }
        swiper.virtual.slides.splice(slidesIndexes[i], 1);
        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
        // shift cache indexes
        Object.keys(swiper.virtual.cache).forEach(key => {
          if (key > slidesIndexes) {
            swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
            swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);
            delete swiper.virtual.cache[key];
          }
        });
      }
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    update(true);
    swiper.slideTo(activeIndex, 0);
  }
  function removeAllSlides() {
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    update(true);
    swiper.slideTo(0, 0);
  }
  on('beforeInit', () => {
    if (!swiper.params.virtual.enabled) return;
    let domSlidesAssigned;
    if (typeof swiper.passedParams.virtual.slides === 'undefined') {
      const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));
      if (slides && slides.length) {
        swiper.virtual.slides = [...slides];
        domSlidesAssigned = true;
        slides.forEach((slideEl, slideIndex) => {
          slideEl.setAttribute('data-swiper-slide-index', slideIndex);
          swiper.virtual.cache[slideIndex] = slideEl;
          slideEl.remove();
        });
      }
    }
    if (!domSlidesAssigned) {
      swiper.virtual.slides = swiper.params.virtual.slides;
    }
    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
    update(false, true);
  });
  on('setTranslate', () => {
    if (!swiper.params.virtual.enabled) return;
    if (swiper.params.cssMode && !swiper._immediateVirtual) {
      clearTimeout(cssModeTimeout);
      cssModeTimeout = setTimeout(() => {
        update();
      }, 100);
    } else {
      update();
    }
  });
  on('init update resize', () => {
    if (!swiper.params.virtual.enabled) return;
    if (swiper.params.cssMode) {
      setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
    }
  });
  Object.assign(swiper.virtual, {
    appendSlide,
    prependSlide,
    removeSlide,
    removeAllSlides,
    update
  });
}

/* eslint-disable consistent-return */
function Keyboard(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const document = getDocument();
  const window = getWindow();
  swiper.keyboard = {
    enabled: false
  };
  extendParams({
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  });
  function handle(event) {
    if (!swiper.enabled) return;
    const {
      rtlTranslate: rtl
    } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    const kc = e.keyCode || e.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40;
    // Directions locks
    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }
    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }
    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }
    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false;
      // Check that swiper should be inside of visible area of window
      if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }
      const el = swiper.el;
      const swiperWidth = el.clientWidth;
      const swiperHeight = el.clientHeight;
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const swiperOffset = elementOffset(el);
      if (rtl) swiperOffset.left -= el.scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
          inView = true;
        }
      }
      if (!inView) return undefined;
    }
    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }
      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }
      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }
    emit('keyPress', kc);
    return undefined;
  }
  function enable() {
    if (swiper.keyboard.enabled) return;
    document.addEventListener('keydown', handle);
    swiper.keyboard.enabled = true;
  }
  function disable() {
    if (!swiper.keyboard.enabled) return;
    document.removeEventListener('keydown', handle);
    swiper.keyboard.enabled = false;
  }
  on('init', () => {
    if (swiper.params.keyboard.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    if (swiper.keyboard.enabled) {
      disable();
    }
  });
  Object.assign(swiper.keyboard, {
    enable,
    disable
  });
}

/* eslint-disable consistent-return */
function Mousewheel(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const window = getWindow();
  extendParams({
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: 'container',
      thresholdDelta: null,
      thresholdTime: null,
      noMousewheelClass: 'swiper-no-mousewheel'
    }
  });
  swiper.mousewheel = {
    enabled: false
  };
  let timeout;
  let lastScrollTime = now();
  let lastEventBeforeSnap;
  const recentWheelEvents = [];
  function normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0;
    let sY = 0; // spinX, spinY
    let pX = 0;
    let pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }
    if (e.shiftKey && !pX) {
      // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }
    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  }
  function handleMouseEnter() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = true;
  }
  function handleMouseLeave() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = false;
  }
  function animateSlider(newEvent) {
    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
      // Prevent if delta of wheel scroll delta is below configured threshold
      return false;
    }
    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
      // Prevent if time between scrolls is below configured threshold
      return false;
    }

    // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).
    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
      // Return false as a default
      return true;
    }
    // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      emit('scroll', newEvent.raw);
    }
    // If you got here is because an animation has been triggered so store the current time
    lastScrollTime = new window.Date().getTime();
    // Return false as a default
    return false;
  }
  function releaseScroll(newEvent) {
    const params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }
    return false;
  }
  function handle(event) {
    let e = event;
    let disableParentSwiper = true;
    if (!swiper.enabled) return;

    // Ignore event if the target or its parents have the swiper-no-mousewheel class
    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
    const params = swiper.params.mousewheel;
    if (swiper.params.cssMode) {
      e.preventDefault();
    }
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    const targetElContainsTarget = targetEl && targetEl.contains(e.target);
    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
    const data = normalize(e);
    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }
    if (delta === 0) return true;
    if (params.invert) delta = -delta;

    // Get the scroll positions
    let positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();

    // When loop is true:
    //     the disableParentSwiper will be true.
    // When loop is false:
    //     if the scroll positions is not on edge,
    //     then the disableParentSwiper will be true.
    //     if the scroll on edge positions,
    //     then the disableParentSwiper will be false.
    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
      // Register the new event in a variable which stores the relevant data
      const newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event
      };

      // Keep the most recent events
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }

      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent);

      // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          animateSlider(newEvent);
        }
      } else {
        animateSlider(newEvent);
      }

      // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.
      if (releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:

      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      const newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        lastEventBeforeSnap = undefined;
        let position = swiper.getTranslate() + delta * params.sensitivity;
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }
        if (swiper.params.loop) {
          swiper.loopFix({
            direction: newEvent.direction < 0 ? 'next' : 'prev',
            byMousewheel: true
          });
        }
        if (swiper.params.freeMode.sticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(timeout);
          timeout = undefined;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift(); // only store the last N events
          }

          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            timeout = nextTick(() => {
              if (swiper.destroyed || !swiper.params) return;
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }

          if (!timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            timeout = nextTick(() => {
              if (swiper.destroyed || !swiper.params) return;
              const snapToThreshold = 0.5;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        }

        // Emit event
        if (!ignoreWheelEvents) emit('scroll', e);

        // Stop autoplay
        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
        // Return page scroll on edge positions
        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {
          return true;
        }
      }
    }
    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    return false;
  }
  function events(method) {
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    targetEl[method]('mouseenter', handleMouseEnter);
    targetEl[method]('mouseleave', handleMouseLeave);
    targetEl[method]('wheel', handle);
  }
  function enable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener('wheel', handle);
      return true;
    }
    if (swiper.mousewheel.enabled) return false;
    events('addEventListener');
    swiper.mousewheel.enabled = true;
    return true;
  }
  function disable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, handle);
      return true;
    }
    if (!swiper.mousewheel.enabled) return false;
    events('removeEventListener');
    swiper.mousewheel.enabled = false;
    return true;
  }
  on('init', () => {
    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
      disable();
    }
    if (swiper.params.mousewheel.enabled) enable();
  });
  on('destroy', () => {
    if (swiper.params.cssMode) {
      enable();
    }
    if (swiper.mousewheel.enabled) disable();
  });
  Object.assign(swiper.mousewheel, {
    enable,
    disable
  });
}

function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach(key => {
      if (!params[key] && params.auto === true) {
        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
        if (!element) {
          element = createElement('div', checkProps[key]);
          element.className = checkProps[key];
          swiper.el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}

function Navigation(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
      navigationDisabledClass: 'swiper-navigation-disabled'
    }
  });
  swiper.navigation = {
    nextEl: null,
    prevEl: null
  };
  function getEl(el) {
    let res;
    if (el && typeof el === 'string' && swiper.isElement) {
      res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
      if (res) return res;
    }
    if (el) {
      if (typeof el === 'string') res = [...document.querySelectorAll(el)];
      if (swiper.params.uniqueNavElements && typeof el === 'string' && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
        res = swiper.el.querySelector(el);
      } else if (res && res.length === 1) {
        res = res[0];
      }
    }
    if (el && !res) return el;
    // if (Array.isArray(res) && res.length === 1) res = res[0];
    return res;
  }
  function toggleEl(el, disabled) {
    const params = swiper.params.navigation;
    el = makeElementsArray(el);
    el.forEach(subEl => {
      if (subEl) {
        subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));
        if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
        }
      }
    });
  }
  function update() {
    // Update Navigation Buttons
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (swiper.params.loop) {
      toggleEl(prevEl, false);
      toggleEl(nextEl, false);
      return;
    }
    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
  }
  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slidePrev();
    emit('navigationPrev');
  }
  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slideNext();
    emit('navigationNext');
  }
  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev'
    });
    if (!(params.nextEl || params.prevEl)) return;
    let nextEl = getEl(params.nextEl);
    let prevEl = getEl(params.prevEl);
    Object.assign(swiper.navigation, {
      nextEl,
      prevEl
    });
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const initButton = (el, dir) => {
      if (el) {
        el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
      }
      if (!swiper.enabled && el) {
        el.classList.add(...params.lockClass.split(' '));
      }
    };
    nextEl.forEach(el => initButton(el, 'next'));
    prevEl.forEach(el => initButton(el, 'prev'));
  }
  function destroy() {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const destroyButton = (el, dir) => {
      el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
      el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));
    };
    nextEl.forEach(el => destroyButton(el, 'next'));
    prevEl.forEach(el => destroyButton(el, 'prev'));
  }
  on('init', () => {
    if (swiper.params.navigation.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      update();
    }
  });
  on('toEdge fromEdge lock unlock', () => {
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (swiper.enabled) {
      update();
      return;
    }
    [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass));
  });
  on('click', (_s, e) => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const targetEl = e.target;
    let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
    if (swiper.isElement && !targetIsButton) {
      const path = e.path || e.composedPath && e.composedPath();
      if (path) {
        targetIsButton = path.find(pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl));
      }
    }
    if (swiper.params.navigation.hideOnClick && !targetIsButton) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
      let isHidden;
      if (nextEl.length) {
        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      } else if (prevEl.length) {
        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit('navigationShow');
      } else {
        emit('navigationHide');
      }
      [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));
    init();
    update();
  };
  const disable = () => {
    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));
    destroy();
  };
  Object.assign(swiper.navigation, {
    enable,
    disable,
    update,
    init,
    destroy
  });
}

function classesToSelector(classes) {
  if (classes === void 0) {
    classes = '';
  }
  return `.${classes.trim().replace(/([\.:!+\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
}

function Pagination(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const pfx = 'swiper-pagination';
  extendParams({
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: number => number,
      formatFractionTotal: number => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`,
      paginationDisabledClass: `${pfx}-disabled`
    }
  });
  swiper.pagination = {
    el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
  }
  function setSideBullets(bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    if (!bulletEl) return;
    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
    if (bulletEl) {
      bulletEl.classList.add(`${bulletActiveClass}-${position}`);
      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
      if (bulletEl) {
        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
      }
    }
  }
  function getMoveDirection(prevIndex, nextIndex, length) {
    prevIndex = prevIndex % length;
    nextIndex = nextIndex % length;
    if (nextIndex === prevIndex + 1) {
      return 'next';
    } else if (nextIndex === prevIndex - 1) {
      return 'previous';
    }
    return;
  }
  function onBulletClick(e) {
    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
    if (!bulletEl) {
      return;
    }
    e.preventDefault();
    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
    if (swiper.params.loop) {
      if (swiper.realIndex === index) return;
      const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
      if (moveDirection === 'next') {
        swiper.slideNext();
      } else if (moveDirection === 'previous') {
        swiper.slidePrev();
      } else {
        swiper.slideToLoop(index);
      }
    } else {
      swiper.slideTo(index);
    }
  }
  function update() {
    // Render || Update Pagination bullets/items
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    // Current/Total
    let current;
    let previousIndex;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      previousIndex = swiper.previousRealIndex || 0;
      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
      previousIndex = swiper.previousSnapIndex;
    } else {
      previousIndex = swiper.previousIndex || 0;
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height');
        el.forEach(subEl => {
          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
        });
        if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {
          dynamicBulletIndex += current - (previousIndex || 0);
          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }
        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.forEach(bulletEl => {
        const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();
        bulletEl.classList.remove(...classesToRemove);
      });
      if (el.length > 1) {
        bullets.forEach(bullet => {
          const bulletIndex = elementIndex(bullet);
          if (bulletIndex === current) {
            bullet.classList.add(...params.bulletActiveClass.split(' '));
          } else if (swiper.isElement) {
            bullet.setAttribute('part', 'bullet');
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
            if (bulletIndex === firstIndex) {
              setSideBullets(bullet, 'prev');
            }
            if (bulletIndex === lastIndex) {
              setSideBullets(bullet, 'next');
            }
          }
        });
      } else {
        const bullet = bullets[current];
        if (bullet) {
          bullet.classList.add(...params.bulletActiveClass.split(' '));
        }
        if (swiper.isElement) {
          bullets.forEach((bulletEl, bulletIndex) => {
            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');
          });
        }
        if (params.dynamicBullets) {
          const firstDisplayedBullet = bullets[firstIndex];
          const lastDisplayedBullet = bullets[lastIndex];
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            if (bullets[i]) {
              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
          }
          setSideBullets(firstDisplayedBullet, 'prev');
          setSideBullets(lastDisplayedBullet, 'next');
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? 'right' : 'left';
        bullets.forEach(bullet => {
          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;
        });
      }
    }
    el.forEach((subEl, subElIndex) => {
      if (params.type === 'fraction') {
        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {
          fractionEl.textContent = params.formatFractionCurrent(current + 1);
        });
        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {
          totalEl.textContent = params.formatFractionTotal(total);
        });
      }
      if (params.type === 'progressbar') {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {
          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
        });
      }
      if (params.type === 'custom' && params.renderCustom) {
        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
        if (subElIndex === 0) emit('paginationRender', subEl);
      } else {
        if (subElIndex === 0) emit('paginationRender', subEl);
        emit('paginationUpdate', subEl);
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
      }
    });
  }
  function render() {
    // Render Container
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    let paginationHTML = '';
    if (params.type === 'bullets') {
      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          // prettier-ignore
          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
      }
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
    }
    swiper.pagination.bullets = [];
    el.forEach(subEl => {
      if (params.type !== 'custom') {
        subEl.innerHTML = paginationHTML || '';
      }
      if (params.type === 'bullets') {
        swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
      }
    });
    if (params.type !== 'custom') {
      emit('paginationRender', el[0]);
    }
  }
  function init() {
    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: 'swiper-pagination'
    });
    const params = swiper.params.pagination;
    if (!params.el) return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = [...document.querySelectorAll(params.el)];
    }
    if (!el) {
      el = params.el;
    }
    if (!el || el.length === 0) return;
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {
      el = [...swiper.el.querySelectorAll(params.el)];
      // check if it belongs to another nested Swiper
      if (el.length > 1) {
        el = el.filter(subEl => {
          if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;
          return true;
        })[0];
      }
    }
    if (Array.isArray(el) && el.length === 1) el = el[0];
    Object.assign(swiper.pagination, {
      el
    });
    el = makeElementsArray(el);
    el.forEach(subEl => {
      if (params.type === 'bullets' && params.clickable) {
        subEl.classList.add(...(params.clickableClass || '').split(' '));
      }
      subEl.classList.add(params.modifierClass + params.type);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === 'bullets' && params.dynamicBullets) {
        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === 'progressbar' && params.progressbarOpposite) {
        subEl.classList.add(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        subEl.addEventListener('click', onBulletClick);
      }
      if (!swiper.enabled) {
        subEl.classList.add(params.lockClass);
      }
    });
  }
  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => {
        subEl.classList.remove(params.hiddenClass);
        subEl.classList.remove(params.modifierClass + params.type);
        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.clickable) {
          subEl.classList.remove(...(params.clickableClass || '').split(' '));
          subEl.removeEventListener('click', onBulletClick);
        }
      });
    }
    if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));
  }
  on('changeDirection', () => {
    if (!swiper.pagination || !swiper.pagination.el) return;
    const params = swiper.params.pagination;
    let {
      el
    } = swiper.pagination;
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on('init', () => {
    if (swiper.params.pagination.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      render();
      update();
    }
  });
  on('activeIndexChange', () => {
    if (typeof swiper.snapIndex === 'undefined') {
      update();
    }
  });
  on('snapIndexChange', () => {
    update();
  });
  on('snapGridLengthChange', () => {
    render();
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));
    }
  });
  on('lock unlock', () => {
    update();
  });
  on('click', (_s, e) => {
    const targetEl = e.target;
    const el = makeElementsArray(swiper.pagination.el);
    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
      if (isHidden === true) {
        emit('paginationShow');
      } else {
        emit('paginationHide');
      }
      el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
    }
    init();
    render();
    update();
  };
  const disable = () => {
    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.pagination, {
    enable,
    disable,
    render,
    update,
    init,
    destroy
  });
}

function Scrollbar(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const document = getDocument();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
      scrollbarDisabledClass: 'swiper-scrollbar-disabled',
      horizontalClass: `swiper-scrollbar-horizontal`,
      verticalClass: `swiper-scrollbar-vertical`
    }
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null
  };
  function setTranslate() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      dragEl,
      el
    } = scrollbar;
    const params = swiper.params.scrollbar;
    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
      dragEl.style.width = `${newSize}px`;
    } else {
      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
      dragEl.style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(timeout);
      el.style.opacity = 1;
      timeout = setTimeout(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = '400ms';
      }, 1000);
    }
  }
  function setTransition(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
  }
  function updateSize() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar
    } = swiper;
    const {
      dragEl,
      el
    } = scrollbar;
    dragEl.style.width = '';
    dragEl.style.height = '';
    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }
    if (swiper.isHorizontal()) {
      dragEl.style.width = `${dragSize}px`;
    } else {
      dragEl.style.height = `${dragSize}px`;
    }
    if (divider >= 1) {
      el.style.display = 'none';
    } else {
      el.style.display = '';
    }
    if (swiper.params.scrollbar.hide) {
      el.style.opacity = 0;
    }
    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);
    }
  }
  function getPointerPosition(e) {
    return swiper.isHorizontal() ? e.clientX : e.clientY;
  }
  function setDragPosition(e) {
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      el
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }
    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  function onDragStart(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el,
      dragEl
    } = scrollbar;
    isTouched = true;
    dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();
    wrapperEl.style.transitionDuration = '100ms';
    dragEl.style.transitionDuration = '100ms';
    setDragPosition(e);
    clearTimeout(dragTimeout);
    el.style.transitionDuration = '0ms';
    if (params.hide) {
      el.style.opacity = 1;
    }
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style['scroll-snap-type'] = 'none';
    }
    emit('scrollbarDragStart', e);
  }
  function onDragMove(e) {
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el,
      dragEl
    } = scrollbar;
    if (!isTouched) return;
    if (e.preventDefault && e.cancelable) e.preventDefault();else e.returnValue = false;
    setDragPosition(e);
    wrapperEl.style.transitionDuration = '0ms';
    el.style.transitionDuration = '0ms';
    dragEl.style.transitionDuration = '0ms';
    emit('scrollbarDragMove', e);
  }
  function onDragEnd(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el
    } = scrollbar;
    if (!isTouched) return;
    isTouched = false;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style['scroll-snap-type'] = '';
      wrapperEl.style.transitionDuration = '';
    }
    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = nextTick(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = '400ms';
      }, 1000);
    }
    emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }
  function events(method) {
    const {
      scrollbar,
      params
    } = swiper;
    const el = scrollbar.el;
    if (!el) return;
    const target = el;
    const activeListener = params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    const passiveListener = params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;
    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
    target[eventMethod]('pointerdown', onDragStart, activeListener);
    document[eventMethod]('pointermove', onDragMove, activeListener);
    document[eventMethod]('pointerup', onDragEnd, passiveListener);
  }
  function enableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events('on');
  }
  function disableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events('off');
  }
  function init() {
    const {
      scrollbar,
      el: swiperEl
    } = swiper;
    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: 'swiper-scrollbar'
    });
    const params = swiper.params.scrollbar;
    if (!params.el) return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = document.querySelectorAll(params.el);
      if (!el.length) return;
    } else if (!el) {
      el = params.el;
    }
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
      el = swiperEl.querySelector(params.el);
    }
    if (el.length > 0) el = el[0];
    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    let dragEl;
    if (el) {
      dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));
      if (!dragEl) {
        dragEl = createElement('div', swiper.params.scrollbar.dragClass);
        el.append(dragEl);
      }
    }
    Object.assign(scrollbar, {
      el,
      dragEl
    });
    if (params.draggable) {
      enableDraggable();
    }
    if (el) {
      el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));
    }
  }
  function destroy() {
    const params = swiper.params.scrollbar;
    const el = swiper.scrollbar.el;
    if (el) {
      el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));
    }
    disableDraggable();
  }
  on('changeDirection', () => {
    if (!swiper.scrollbar || !swiper.scrollbar.el) return;
    const params = swiper.params.scrollbar;
    let {
      el
    } = swiper.scrollbar;
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on('init', () => {
    if (swiper.params.scrollbar.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      updateSize();
      setTranslate();
    }
  });
  on('update resize observerUpdate lock unlock changeDirection', () => {
    updateSize();
  });
  on('setTranslate', () => {
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    setTransition(duration);
  });
  on('enable disable', () => {
    const {
      el
    } = swiper.scrollbar;
    if (el) {
      el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));
    }
  });
  on('destroy', () => {
    destroy();
  });
  const enable = () => {
    swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    }
    init();
    updateSize();
    setTranslate();
  };
  const disable = () => {
    swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.scrollbar, {
    enable,
    disable,
    updateSize,
    setTranslate,
    init,
    destroy
  });
}

function Parallax(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    parallax: {
      enabled: false
    }
  });
  const elementsSelector = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]';
  const setTransform = (el, progress) => {
    const {
      rtl
    } = swiper;
    const rtlFactor = rtl ? -1 : 1;
    const p = el.getAttribute('data-swiper-parallax') || '0';
    let x = el.getAttribute('data-swiper-parallax-x');
    let y = el.getAttribute('data-swiper-parallax-y');
    const scale = el.getAttribute('data-swiper-parallax-scale');
    const opacity = el.getAttribute('data-swiper-parallax-opacity');
    const rotate = el.getAttribute('data-swiper-parallax-rotate');
    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }
    if (x.indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if (y.indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }
    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
      el.style.opacity = currentOpacity;
    }
    let transform = `translate3d(${x}, ${y}, 0px)`;
    if (typeof scale !== 'undefined' && scale !== null) {
      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
      transform += ` scale(${currentScale})`;
    }
    if (rotate && typeof rotate !== 'undefined' && rotate !== null) {
      const currentRotate = rotate * progress * -1;
      transform += ` rotate(${currentRotate}deg)`;
    }
    el.style.transform = transform;
  };
  const setTranslate = () => {
    const {
      el,
      slides,
      progress,
      snapGrid,
      isElement
    } = swiper;
    const elements = elementChildren(el, elementsSelector);
    if (swiper.isElement) {
      elements.push(...elementChildren(swiper.hostEl, elementsSelector));
    }
    elements.forEach(subEl => {
      setTransform(subEl, progress);
    });
    slides.forEach((slideEl, slideIndex) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {
        setTransform(subEl, slideProgress);
      });
    });
  };
  const setTransition = function (duration) {
    if (duration === void 0) {
      duration = swiper.params.speed;
    }
    const {
      el,
      hostEl
    } = swiper;
    const elements = [...el.querySelectorAll(elementsSelector)];
    if (swiper.isElement) {
      elements.push(...hostEl.querySelectorAll(elementsSelector));
    }
    elements.forEach(parallaxEl => {
      let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;
      if (duration === 0) parallaxDuration = 0;
      parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;
    });
  };
  on('beforeInit', () => {
    if (!swiper.params.parallax.enabled) return;
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
  });
  on('init', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTranslate', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTransition', (_swiper, duration) => {
    if (!swiper.params.parallax.enabled) return;
    setTransition(duration);
  });
}

function Zoom(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const window = getWindow();
  extendParams({
    zoom: {
      enabled: false,
      limitToOriginalSize: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed'
    }
  });
  swiper.zoom = {
    enabled: false
  };
  let currentScale = 1;
  let isScaling = false;
  let fakeGestureTouched;
  let fakeGestureMoved;
  const evCache = [];
  const gesture = {
    originX: 0,
    originY: 0,
    slideEl: undefined,
    slideWidth: undefined,
    slideHeight: undefined,
    imageEl: undefined,
    imageWrapEl: undefined,
    maxRatio: 3
  };
  const image = {
    isTouched: undefined,
    isMoved: undefined,
    currentX: undefined,
    currentY: undefined,
    minX: undefined,
    minY: undefined,
    maxX: undefined,
    maxY: undefined,
    width: undefined,
    height: undefined,
    startX: undefined,
    startY: undefined,
    touchesStart: {},
    touchesCurrent: {}
  };
  const velocity = {
    x: undefined,
    y: undefined,
    prevPositionX: undefined,
    prevPositionY: undefined,
    prevTime: undefined
  };
  let scale = 1;
  Object.defineProperty(swiper.zoom, 'scale', {
    get() {
      return scale;
    },
    set(value) {
      if (scale !== value) {
        const imageEl = gesture.imageEl;
        const slideEl = gesture.slideEl;
        emit('zoomChange', value, imageEl, slideEl);
      }
      scale = value;
    }
  });
  function getDistanceBetweenTouches() {
    if (evCache.length < 2) return 1;
    const x1 = evCache[0].pageX;
    const y1 = evCache[0].pageY;
    const x2 = evCache[1].pageX;
    const y2 = evCache[1].pageY;
    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    return distance;
  }
  function getMaxRatio() {
    const params = swiper.params.zoom;
    const maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
    if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {
      const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;
      return Math.min(imageMaxRatio, maxRatio);
    }
    return maxRatio;
  }
  function getScaleOrigin() {
    if (evCache.length < 2) return {
      x: null,
      y: null
    };
    const box = gesture.imageEl.getBoundingClientRect();
    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];
  }
  function getSlideSelector() {
    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  }
  function eventWithinSlide(e) {
    const slideSelector = getSlideSelector();
    if (e.target.matches(slideSelector)) return true;
    if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;
    return false;
  }
  function eventWithinZoomContainer(e) {
    const selector = `.${swiper.params.zoom.containerClass}`;
    if (e.target.matches(selector)) return true;
    if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;
    return false;
  }

  // Events
  function onGestureStart(e) {
    if (e.pointerType === 'mouse') {
      evCache.splice(0, evCache.length);
    }
    if (!eventWithinSlide(e)) return;
    const params = swiper.params.zoom;
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    evCache.push(e);
    if (evCache.length < 2) {
      return;
    }
    fakeGestureTouched = true;
    gesture.scaleStart = getDistanceBetweenTouches();
    if (!gesture.slideEl) {
      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
      if (!gesture.imageWrapEl) {
        gesture.imageEl = undefined;
        return;
      }
      gesture.maxRatio = getMaxRatio();
    }
    if (gesture.imageEl) {
      const [originX, originY] = getScaleOrigin();
      gesture.originX = originX;
      gesture.originY = originY;
      gesture.imageEl.style.transitionDuration = '0ms';
    }
    isScaling = true;
  }
  function onGestureChange(e) {
    if (!eventWithinSlide(e)) return;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0) evCache[pointerIndex] = e;
    if (evCache.length < 2) {
      return;
    }
    fakeGestureMoved = true;
    gesture.scaleMove = getDistanceBetweenTouches();
    if (!gesture.imageEl) {
      return;
    }
    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
    }
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
  }
  function onGestureEnd(e) {
    if (!eventWithinSlide(e)) return;
    if (e.pointerType === 'mouse' && e.type === 'pointerout') return;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);
    if (!fakeGestureTouched || !fakeGestureMoved) {
      return;
    }
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    if (!gesture.imageEl) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
    currentScale = zoom.scale;
    isScaling = false;
    if (zoom.scale > 1 && gesture.slideEl) {
      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
    } else if (zoom.scale <= 1 && gesture.slideEl) {
      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
    }
    if (zoom.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
      gesture.slideEl = undefined;
    }
  }
  let allowTouchMoveTimeout;
  function allowTouchMove() {
    swiper.touchEventsData.preventTouchMoveFromPointerMove = false;
  }
  function preventTouchMove() {
    clearTimeout(allowTouchMoveTimeout);
    swiper.touchEventsData.preventTouchMoveFromPointerMove = true;
    allowTouchMoveTimeout = setTimeout(() => {
      if (swiper.destroyed) return;
      allowTouchMove();
    });
  }
  function onTouchStart(e) {
    const device = swiper.device;
    if (!gesture.imageEl) return;
    if (image.isTouched) return;
    if (device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    const event = evCache.length > 0 ? evCache[0] : e;
    image.touchesStart.x = event.pageX;
    image.touchesStart.y = event.pageY;
  }
  function onTouchMove(e) {
    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {
      return;
    }
    const zoom = swiper.zoom;
    if (!gesture.imageEl) {
      return;
    }
    if (!image.isTouched || !gesture.slideEl) {
      return;
    }
    if (!image.isMoved) {
      image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;
      image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;
      gesture.slideWidth = gesture.slideEl.offsetWidth;
      gesture.slideHeight = gesture.slideEl.offsetHeight;
      gesture.imageWrapEl.style.transitionDuration = '0ms';
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;
    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;
    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
    if (touchesDiff > 5) {
      swiper.allowClick = false;
    }
    if (!image.isMoved && !isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        allowTouchMove();
        return;
      }
      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        allowTouchMove();
        return;
      }
    }
    if (e.cancelable) {
      e.preventDefault();
    }
    e.stopPropagation();
    preventTouchMove();
    image.isMoved = true;
    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
    const {
      originX,
      originY
    } = gesture;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
    }
    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
    }
    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
    }
    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
  }
  function onTouchEnd() {
    const zoom = swiper.zoom;
    if (!gesture.imageEl) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY;
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
  }
  function onTransitionEnd() {
    const zoom = swiper.zoom;
    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
      if (gesture.imageEl) {
        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
      }
      if (gesture.imageWrapEl) {
        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
      }
      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);
      zoom.scale = 1;
      currentScale = 1;
      gesture.slideEl = undefined;
      gesture.imageEl = undefined;
      gesture.imageWrapEl = undefined;
      gesture.originX = 0;
      gesture.originY = 0;
    }
  }
  function zoomIn(e) {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (e && e.target) {
        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      }
      if (!gesture.slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
        } else {
          gesture.slideEl = swiper.slides[swiper.activeIndex];
        }
      }
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl) return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.touchAction = 'none';
    }
    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;
    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.pageX;
      touchY = e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }
    const forceZoomRatio = typeof e === 'number' ? e : null;
    if (currentScale === 1 && forceZoomRatio) {
      touchX = undefined;
      touchY = undefined;
      image.touchesStart.x = undefined;
      image.touchesStart.y = undefined;
    }
    const maxRatio = getMaxRatio();
    zoom.scale = forceZoomRatio || maxRatio;
    currentScale = forceZoomRatio || maxRatio;
    if (e && !(currentScale === 1 && forceZoomRatio)) {
      slideWidth = gesture.slideEl.offsetWidth;
      slideHeight = gesture.slideEl.offsetHeight;
      offsetX = elementOffset(gesture.slideEl).left + window.scrollX;
      offsetY = elementOffset(gesture.slideEl).top + window.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;
      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }
      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    if (forceZoomRatio && zoom.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
    }
    gesture.imageWrapEl.style.transitionDuration = '300ms';
    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
    gesture.imageEl.style.transitionDuration = '300ms';
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
  }
  function zoomOut() {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
      } else {
        gesture.slideEl = swiper.slides[swiper.activeIndex];
      }
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl) return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = '';
      swiper.wrapperEl.style.touchAction = '';
    }
    zoom.scale = 1;
    currentScale = 1;
    image.touchesStart.x = undefined;
    image.touchesStart.y = undefined;
    gesture.imageWrapEl.style.transitionDuration = '300ms';
    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
    gesture.imageEl.style.transitionDuration = '300ms';
    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
    gesture.slideEl = undefined;
    gesture.originX = 0;
    gesture.originY = 0;
  }

  // Toggle Zoom
  function zoomToggle(e) {
    const zoom = swiper.zoom;
    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoomOut();
    } else {
      // Zoom In
      zoomIn(e);
    }
  }
  function getListeners() {
    const passiveListener = swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    const activeListenerWithCapture = swiper.params.passiveListeners ? {
      passive: false,
      capture: true
    } : true;
    return {
      passiveListener,
      activeListenerWithCapture
    };
  }

  // Attach/Detach Events
  function enable() {
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();

    // Scale image
    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);
    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);
    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);
    });

    // Move image
    swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);
  }
  function disable() {
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;
    zoom.enabled = false;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();

    // Scale image
    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);
    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);
    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);
    });

    // Move image
    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);
  }
  on('init', () => {
    if (swiper.params.zoom.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    disable();
  });
  on('touchStart', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchStart(e);
  });
  on('touchEnd', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchEnd();
  });
  on('doubleTap', (_s, e) => {
    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
      zoomToggle(e);
    }
  });
  on('transitionEnd', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
      onTransitionEnd();
    }
  });
  on('slideChange', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
      onTransitionEnd();
    }
  });
  Object.assign(swiper.zoom, {
    enable,
    disable,
    in: zoomIn,
    out: zoomOut,
    toggle: zoomToggle
  });
}

/* eslint no-bitwise: ["error", { "allow": [">>"] }] */
function Controller(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide' // or 'container'
    }
  });

  swiper.controller = {
    control: undefined
  };
  function LinearSpline(x, y) {
    const binarySearch = function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }();
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;
    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2x1)  (y3y1))  (x3x1) + y1
      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
    };
    return this;
  }
  function getInterpolateFunction(c) {
    swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
  }
  function setTranslate(_t, byController) {
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    const Swiper = swiper.constructor;
    function setControlledTranslate(c) {
      if (c.destroyed) return;

      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }
      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
          multiplier = 1;
        }
        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
      }
      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  }
  function setTransition(duration, byController) {
    const Swiper = swiper.constructor;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      if (c.destroyed) return;
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        if (c.params.autoHeight) {
          nextTick(() => {
            c.updateAutoHeight();
          });
        }
        elementTransitionEnd(c.wrapperEl, () => {
          if (!controlled) return;
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  }
  function removeSpline() {
    if (!swiper.controller.control) return;
    if (swiper.controller.spline) {
      swiper.controller.spline = undefined;
      delete swiper.controller.spline;
    }
  }
  on('beforeInit', () => {
    if (typeof window !== 'undefined' && (
    // eslint-disable-line
    typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {
      const controlElements = typeof swiper.params.controller.control === 'string' ? [...document.querySelectorAll(swiper.params.controller.control)] : [swiper.params.controller.control];
      controlElements.forEach(controlElement => {
        if (!swiper.controller.control) swiper.controller.control = [];
        if (controlElement && controlElement.swiper) {
          swiper.controller.control.push(controlElement.swiper);
        } else if (controlElement) {
          const eventName = `${swiper.params.eventsPrefix}init`;
          const onControllerSwiper = e => {
            swiper.controller.control.push(e.detail[0]);
            swiper.update();
            controlElement.removeEventListener(eventName, onControllerSwiper);
          };
          controlElement.addEventListener(eventName, onControllerSwiper);
        }
      });
      return;
    }
    swiper.controller.control = swiper.params.controller.control;
  });
  on('update', () => {
    removeSpline();
  });
  on('resize', () => {
    removeSpline();
  });
  on('observerUpdate', () => {
    removeSpline();
  });
  on('setTranslate', (_s, translate, byController) => {
    if (!swiper.controller.control || swiper.controller.control.destroyed) return;
    swiper.controller.setTranslate(translate, byController);
  });
  on('setTransition', (_s, duration, byController) => {
    if (!swiper.controller.control || swiper.controller.control.destroyed) return;
    swiper.controller.setTransition(duration, byController);
  });
  Object.assign(swiper.controller, {
    setTranslate,
    setTransition
  });
}

function A11y(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
      slideLabelMessage: '{{index}} / {{slidesLength}}',
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      containerRole: null,
      itemRoleDescriptionMessage: null,
      slideRole: 'group',
      id: null,
      scrollOnFocus: true
    }
  });
  swiper.a11y = {
    clicked: false
  };
  let liveRegion = null;
  let preventFocusHandler;
  let focusTargetSlideEl;
  let visibilityChangedTimestamp = new Date().getTime();
  function notify(message) {
    const notification = liveRegion;
    if (notification.length === 0) return;
    notification.innerHTML = '';
    notification.innerHTML = message;
  }
  function getRandomNumber(size) {
    const randomChar = () => Math.round(16 * Math.random()).toString(16);
    return 'x'.repeat(size).replace(/x/g, randomChar);
  }
  function makeElFocusable(el) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('tabIndex', '0');
    });
  }
  function makeElNotFocusable(el) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('tabIndex', '-1');
    });
  }
  function addElRole(el, role) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('role', role);
    });
  }
  function addElRoleDescription(el, description) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-roledescription', description);
    });
  }
  function addElControls(el, controls) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-controls', controls);
    });
  }
  function addElLabel(el, label) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-label', label);
    });
  }
  function addElId(el, id) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('id', id);
    });
  }
  function addElLive(el, live) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-live', live);
    });
  }
  function disableEl(el) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-disabled', true);
    });
  }
  function enableEl(el) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-disabled', false);
    });
  }
  function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32) return;
    const params = swiper.params.a11y;
    const targetEl = e.target;
    if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {
      if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;
    }
    if (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {
      const prevEls = makeElementsArray(swiper.navigation.prevEl);
      const nextEls = makeElementsArray(swiper.navigation.nextEl);
      if (nextEls.includes(targetEl)) {
        if (!(swiper.isEnd && !swiper.params.loop)) {
          swiper.slideNext();
        }
        if (swiper.isEnd) {
          notify(params.lastSlideMessage);
        } else {
          notify(params.nextSlideMessage);
        }
      }
      if (prevEls.includes(targetEl)) {
        if (!(swiper.isBeginning && !swiper.params.loop)) {
          swiper.slidePrev();
        }
        if (swiper.isBeginning) {
          notify(params.firstSlideMessage);
        } else {
          notify(params.prevSlideMessage);
        }
      }
    }
    if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {
      targetEl.click();
    }
  }
  function updateNavigation() {
    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (prevEl) {
      if (swiper.isBeginning) {
        disableEl(prevEl);
        makeElNotFocusable(prevEl);
      } else {
        enableEl(prevEl);
        makeElFocusable(prevEl);
      }
    }
    if (nextEl) {
      if (swiper.isEnd) {
        disableEl(nextEl);
        makeElNotFocusable(nextEl);
      } else {
        enableEl(nextEl);
        makeElFocusable(nextEl);
      }
    }
  }
  function hasPagination() {
    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
  }
  function hasClickablePagination() {
    return hasPagination() && swiper.params.pagination.clickable;
  }
  function updatePagination() {
    const params = swiper.params.a11y;
    if (!hasPagination()) return;
    swiper.pagination.bullets.forEach(bulletEl => {
      if (swiper.params.pagination.clickable) {
        makeElFocusable(bulletEl);
        if (!swiper.params.pagination.renderBullet) {
          addElRole(bulletEl, 'button');
          addElLabel(bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, elementIndex(bulletEl) + 1));
        }
      }
      if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {
        bulletEl.setAttribute('aria-current', 'true');
      } else {
        bulletEl.removeAttribute('aria-current');
      }
    });
  }
  const initNavEl = (el, wrapperId, message) => {
    makeElFocusable(el);
    if (el.tagName !== 'BUTTON') {
      addElRole(el, 'button');
      el.addEventListener('keydown', onEnterOrSpaceKey);
    }
    addElLabel(el, message);
    addElControls(el, wrapperId);
  };
  const handlePointerDown = e => {
    if (focusTargetSlideEl && focusTargetSlideEl !== e.target && !focusTargetSlideEl.contains(e.target)) {
      preventFocusHandler = true;
    }
    swiper.a11y.clicked = true;
  };
  const handlePointerUp = () => {
    preventFocusHandler = false;
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (!swiper.destroyed) {
          swiper.a11y.clicked = false;
        }
      });
    });
  };
  const onVisibilityChange = e => {
    visibilityChangedTimestamp = new Date().getTime();
  };
  const handleFocus = e => {
    if (swiper.a11y.clicked || !swiper.params.a11y.scrollOnFocus) return;
    if (new Date().getTime() - visibilityChangedTimestamp < 100) return;
    const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
    if (!slideEl || !swiper.slides.includes(slideEl)) return;
    focusTargetSlideEl = slideEl;
    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
    if (isActive || isVisible) return;
    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
    if (swiper.isHorizontal()) {
      swiper.el.scrollLeft = 0;
    } else {
      swiper.el.scrollTop = 0;
    }
    requestAnimationFrame(() => {
      if (preventFocusHandler) return;
      if (swiper.params.loop) {
        swiper.slideToLoop(parseInt(slideEl.getAttribute('data-swiper-slide-index')), 0);
      } else {
        swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
      }
      preventFocusHandler = false;
    });
  };
  const initSlides = () => {
    const params = swiper.params.a11y;
    if (params.itemRoleDescriptionMessage) {
      addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);
    }
    if (params.slideRole) {
      addElRole(swiper.slides, params.slideRole);
    }
    const slidesLength = swiper.slides.length;
    if (params.slideLabelMessage) {
      swiper.slides.forEach((slideEl, index) => {
        const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;
        const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
        addElLabel(slideEl, ariaLabelMessage);
      });
    }
  };
  const init = () => {
    const params = swiper.params.a11y;
    swiper.el.append(liveRegion);

    // Container
    const containerEl = swiper.el;
    if (params.containerRoleDescriptionMessage) {
      addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);
    }
    if (params.containerMessage) {
      addElLabel(containerEl, params.containerMessage);
    }
    if (params.containerRole) {
      addElRole(containerEl, params.containerRole);
    }

    // Wrapper
    const wrapperEl = swiper.wrapperEl;
    const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;
    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
    addElId(wrapperEl, wrapperId);
    addElLive(wrapperEl, live);

    // Slide
    initSlides();

    // Navigation
    let {
      nextEl,
      prevEl
    } = swiper.navigation ? swiper.navigation : {};
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (nextEl) {
      nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));
    }
    if (prevEl) {
      prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));
    }

    // Pagination
    if (hasClickablePagination()) {
      const paginationEl = makeElementsArray(swiper.pagination.el);
      paginationEl.forEach(el => {
        el.addEventListener('keydown', onEnterOrSpaceKey);
      });
    }

    // Tab focus
    const document = getDocument();
    document.addEventListener('visibilitychange', onVisibilityChange);
    swiper.el.addEventListener('focus', handleFocus, true);
    swiper.el.addEventListener('focus', handleFocus, true);
    swiper.el.addEventListener('pointerdown', handlePointerDown, true);
    swiper.el.addEventListener('pointerup', handlePointerUp, true);
  };
  function destroy() {
    if (liveRegion) liveRegion.remove();
    let {
      nextEl,
      prevEl
    } = swiper.navigation ? swiper.navigation : {};
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (nextEl) {
      nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
    }
    if (prevEl) {
      prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
    }

    // Pagination
    if (hasClickablePagination()) {
      const paginationEl = makeElementsArray(swiper.pagination.el);
      paginationEl.forEach(el => {
        el.removeEventListener('keydown', onEnterOrSpaceKey);
      });
    }
    const document = getDocument();
    document.removeEventListener('visibilitychange', onVisibilityChange);
    // Tab focus
    if (swiper.el && typeof swiper.el !== 'string') {
      swiper.el.removeEventListener('focus', handleFocus, true);
      swiper.el.removeEventListener('pointerdown', handlePointerDown, true);
      swiper.el.removeEventListener('pointerup', handlePointerUp, true);
    }
  }
  on('beforeInit', () => {
    liveRegion = createElement('span', swiper.params.a11y.notificationClass);
    liveRegion.setAttribute('aria-live', 'assertive');
    liveRegion.setAttribute('aria-atomic', 'true');
  });
  on('afterInit', () => {
    if (!swiper.params.a11y.enabled) return;
    init();
  });
  on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {
    if (!swiper.params.a11y.enabled) return;
    initSlides();
  });
  on('fromEdge toEdge afterInit lock unlock', () => {
    if (!swiper.params.a11y.enabled) return;
    updateNavigation();
  });
  on('paginationUpdate', () => {
    if (!swiper.params.a11y.enabled) return;
    updatePagination();
  });
  on('destroy', () => {
    if (!swiper.params.a11y.enabled) return;
    destroy();
  });
}

function History(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    history: {
      enabled: false,
      root: '',
      replaceState: false,
      key: 'slides',
      keepQuery: false
    }
  });
  let initialized = false;
  let paths = {};
  const slugify = text => {
    return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
  };
  const getPathValues = urlOverride => {
    const window = getWindow();
    let location;
    if (urlOverride) {
      location = new URL(urlOverride);
    } else {
      location = window.location;
    }
    const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return {
      key,
      value
    };
  };
  const setHistory = (key, index) => {
    const window = getWindow();
    if (!initialized || !swiper.params.history.enabled) return;
    let location;
    if (swiper.params.url) {
      location = new URL(swiper.params.url);
    } else {
      location = window.location;
    }
    const slide = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${index}"]`) : swiper.slides[index];
    let value = slugify(slide.getAttribute('data-history'));
    if (swiper.params.history.root.length > 0) {
      let root = swiper.params.history.root;
      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
      value = `${root}/${key ? `${key}/` : ''}${value}`;
    } else if (!location.pathname.includes(key)) {
      value = `${key ? `${key}/` : ''}${value}`;
    }
    if (swiper.params.history.keepQuery) {
      value += location.search;
    }
    const currentState = window.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      window.history.replaceState({
        value
      }, null, value);
    } else {
      window.history.pushState({
        value
      }, null, value);
    }
  };
  const scrollToSlide = (speed, value, runCallbacks) => {
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides[i];
        const slideHistory = slugify(slide.getAttribute('data-history'));
        if (slideHistory === value) {
          const index = swiper.getSlideIndex(slide);
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  };
  const setHistoryPopState = () => {
    paths = getPathValues(swiper.params.url);
    scrollToSlide(swiper.params.speed, paths.value, false);
  };
  const init = () => {
    const window = getWindow();
    if (!swiper.params.history) return;
    if (!window.history || !window.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    initialized = true;
    paths = getPathValues(swiper.params.url);
    if (!paths.key && !paths.value) {
      if (!swiper.params.history.replaceState) {
        window.addEventListener('popstate', setHistoryPopState);
      }
      return;
    }
    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      window.addEventListener('popstate', setHistoryPopState);
    }
  };
  const destroy = () => {
    const window = getWindow();
    if (!swiper.params.history.replaceState) {
      window.removeEventListener('popstate', setHistoryPopState);
    }
  };
  on('init', () => {
    if (swiper.params.history.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.history.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
}

function HashNavigation(_ref) {
  let {
    swiper,
    extendParams,
    emit,
    on
  } = _ref;
  let initialized = false;
  const document = getDocument();
  const window = getWindow();
  extendParams({
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
      getSlideIndex(_s, hash) {
        if (swiper.virtual && swiper.params.virtual.enabled) {
          const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];
          if (!slideWithHash) return 0;
          const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);
          return index;
        }
        return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash="${hash}"], swiper-slide[data-hash="${hash}"]`)[0]);
      }
    }
  });
  const onHashChange = () => {
    emit('hashChange');
    const newHash = document.location.hash.replace('#', '');
    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);
      if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;
      swiper.slideTo(newIndex);
    }
  };
  const setHash = () => {
    if (!initialized || !swiper.params.hashNavigation.enabled) return;
    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';
    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
      window.history.replaceState(null, null, `#${activeSlideHash}` || '');
      emit('hashSet');
    } else {
      document.location.hash = activeSlideHash || '';
      emit('hashSet');
    }
  };
  const init = () => {
    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
    initialized = true;
    const hash = document.location.hash.replace('#', '');
    if (hash) {
      const speed = 0;
      const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);
      swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);
    }
    if (swiper.params.hashNavigation.watchState) {
      window.addEventListener('hashchange', onHashChange);
    }
  };
  const destroy = () => {
    if (swiper.params.hashNavigation.watchState) {
      window.removeEventListener('hashchange', onHashChange);
    }
  };
  on('init', () => {
    if (swiper.params.hashNavigation.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.hashNavigation.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHash();
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHash();
    }
  });
}

/* eslint no-underscore-dangle: "off" */
/* eslint no-use-before-define: "off" */
function Autoplay(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
    params
  } = _ref;
  swiper.autoplay = {
    running: false,
    paused: false,
    timeLeft: 0
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: false,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });
  let timeout;
  let raf;
  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;
  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;
  let autoplayTimeLeft;
  let autoplayStartTime = new Date().getTime();
  let wasPaused;
  let isTouched;
  let pausedByTouch;
  let touchStartTimeout;
  let slideChanged;
  let pausedByInteraction;
  let pausedByPointerEnter;
  function onTransitionEnd(e) {
    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
    if (e.target !== swiper.wrapperEl) return;
    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);
    if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {
      return;
    }
    resume();
  }
  const calcTimeLeft = () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (swiper.autoplay.paused) {
      wasPaused = true;
    } else if (wasPaused) {
      autoplayDelayCurrent = autoplayTimeLeft;
      wasPaused = false;
    }
    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();
    swiper.autoplay.timeLeft = timeLeft;
    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);
    raf = requestAnimationFrame(() => {
      calcTimeLeft();
    });
  };
  const getSlideDelay = () => {
    let activeSlideEl;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];
    } else {
      activeSlideEl = swiper.slides[swiper.activeIndex];
    }
    if (!activeSlideEl) return undefined;
    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);
    return currentSlideDelay;
  };
  const run = delayForce => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    cancelAnimationFrame(raf);
    calcTimeLeft();
    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;
    autoplayDelayTotal = swiper.params.autoplay.delay;
    autoplayDelayCurrent = swiper.params.autoplay.delay;
    const currentSlideDelay = getSlideDelay();
    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {
      delay = currentSlideDelay;
      autoplayDelayTotal = currentSlideDelay;
      autoplayDelayCurrent = currentSlideDelay;
    }
    autoplayTimeLeft = delay;
    const speed = swiper.params.speed;
    const proceed = () => {
      if (!swiper || swiper.destroyed) return;
      if (swiper.params.autoplay.reverseDirection) {
        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
          swiper.slidePrev(speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, speed, true, true);
          emit('autoplay');
        }
      } else {
        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
          swiper.slideNext(speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(0, speed, true, true);
          emit('autoplay');
        }
      }
      if (swiper.params.cssMode) {
        autoplayStartTime = new Date().getTime();
        requestAnimationFrame(() => {
          run();
        });
      }
    };
    if (delay > 0) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        proceed();
      }, delay);
    } else {
      requestAnimationFrame(() => {
        proceed();
      });
    }

    // eslint-disable-next-line
    return delay;
  };
  const start = () => {
    autoplayStartTime = new Date().getTime();
    swiper.autoplay.running = true;
    run();
    emit('autoplayStart');
  };
  const stop = () => {
    swiper.autoplay.running = false;
    clearTimeout(timeout);
    cancelAnimationFrame(raf);
    emit('autoplayStop');
  };
  const pause = (internal, reset) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    clearTimeout(timeout);
    if (!internal) {
      pausedByInteraction = true;
    }
    const proceed = () => {
      emit('autoplayPause');
      if (swiper.params.autoplay.waitForTransition) {
        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);
      } else {
        resume();
      }
    };
    swiper.autoplay.paused = true;
    if (reset) {
      if (slideChanged) {
        autoplayTimeLeft = swiper.params.autoplay.delay;
      }
      slideChanged = false;
      proceed();
      return;
    }
    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
    proceed();
  };
  const resume = () => {
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
    autoplayStartTime = new Date().getTime();
    if (pausedByInteraction) {
      pausedByInteraction = false;
      run(autoplayTimeLeft);
    } else {
      run();
    }
    swiper.autoplay.paused = false;
    emit('autoplayResume');
  };
  const onVisibilityChange = () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    const document = getDocument();
    if (document.visibilityState === 'hidden') {
      pausedByInteraction = true;
      pause(true);
    }
    if (document.visibilityState === 'visible') {
      resume();
    }
  };
  const onPointerEnter = e => {
    if (e.pointerType !== 'mouse') return;
    pausedByInteraction = true;
    pausedByPointerEnter = true;
    if (swiper.animating || swiper.autoplay.paused) return;
    pause(true);
  };
  const onPointerLeave = e => {
    if (e.pointerType !== 'mouse') return;
    pausedByPointerEnter = false;
    if (swiper.autoplay.paused) {
      resume();
    }
  };
  const attachMouseEvents = () => {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.el.addEventListener('pointerenter', onPointerEnter);
      swiper.el.addEventListener('pointerleave', onPointerLeave);
    }
  };
  const detachMouseEvents = () => {
    if (swiper.el && typeof swiper.el !== 'string') {
      swiper.el.removeEventListener('pointerenter', onPointerEnter);
      swiper.el.removeEventListener('pointerleave', onPointerLeave);
    }
  };
  const attachDocumentEvents = () => {
    const document = getDocument();
    document.addEventListener('visibilitychange', onVisibilityChange);
  };
  const detachDocumentEvents = () => {
    const document = getDocument();
    document.removeEventListener('visibilitychange', onVisibilityChange);
  };
  on('init', () => {
    if (swiper.params.autoplay.enabled) {
      attachMouseEvents();
      attachDocumentEvents();
      start();
    }
  });
  on('destroy', () => {
    detachMouseEvents();
    detachDocumentEvents();
    if (swiper.autoplay.running) {
      stop();
    }
  });
  on('_freeModeStaticRelease', () => {
    if (pausedByTouch || pausedByInteraction) {
      resume();
    }
  });
  on('_freeModeNoMomentumRelease', () => {
    if (!swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on('beforeTransitionStart', (_s, speed, internal) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (internal || !swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on('sliderFirstMove', () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (swiper.params.autoplay.disableOnInteraction) {
      stop();
      return;
    }
    isTouched = true;
    pausedByTouch = false;
    pausedByInteraction = false;
    touchStartTimeout = setTimeout(() => {
      pausedByInteraction = true;
      pausedByTouch = true;
      pause(true);
    }, 200);
  });
  on('touchEnd', () => {
    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
    clearTimeout(touchStartTimeout);
    clearTimeout(timeout);
    if (swiper.params.autoplay.disableOnInteraction) {
      pausedByTouch = false;
      isTouched = false;
      return;
    }
    if (pausedByTouch && swiper.params.cssMode) resume();
    pausedByTouch = false;
    isTouched = false;
  });
  on('slideChange', () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    slideChanged = true;
  });
  Object.assign(swiper.autoplay, {
    start,
    stop,
    pause,
    resume
  });
}

function Thumb(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-thumbs'
    }
  });
  let initialized = false;
  let swiperCreated = false;
  swiper.thumbs = {
    swiper: null
  };
  function onThumbClick() {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      swiper.slideToLoop(slideToIndex);
    } else {
      swiper.slideTo(slideToIndex);
    }
  }
  function init() {
    const {
      thumbs: thumbsParams
    } = swiper.params;
    if (initialized) return false;
    initialized = true;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Object.assign(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      Object.assign(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper.update();
    } else if (isObject$1(thumbsParams.swiper)) {
      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
      Object.assign(thumbsSwiperParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
      swiperCreated = true;
    }
    swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', onThumbClick);
    return true;
  }
  function update(initial) {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;

    // Activate thumbs
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }
    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }
    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));
    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i}"]`).forEach(slideEl => {
          slideEl.classList.add(thumbActiveClass);
        });
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        if (thumbsSwiper.slides[swiper.realIndex + i]) {
          thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);
        }
      }
    }
    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      const currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;
      if (thumbsSwiper.params.loop) {
        const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];
        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }
      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }
      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    }
  }
  on('beforeInit', () => {
    const {
      thumbs
    } = swiper.params;
    if (!thumbs || !thumbs.swiper) return;
    if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {
      const document = getDocument();
      const getThumbsElementAndInit = () => {
        const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;
        if (thumbsElement && thumbsElement.swiper) {
          thumbs.swiper = thumbsElement.swiper;
          init();
          update(true);
        } else if (thumbsElement) {
          const eventName = `${swiper.params.eventsPrefix}init`;
          const onThumbsSwiper = e => {
            thumbs.swiper = e.detail[0];
            thumbsElement.removeEventListener(eventName, onThumbsSwiper);
            init();
            update(true);
            thumbs.swiper.update();
            swiper.update();
          };
          thumbsElement.addEventListener(eventName, onThumbsSwiper);
        }
        return thumbsElement;
      };
      const watchForThumbsToAppear = () => {
        if (swiper.destroyed) return;
        const thumbsElement = getThumbsElementAndInit();
        if (!thumbsElement) {
          requestAnimationFrame(watchForThumbsToAppear);
        }
      };
      requestAnimationFrame(watchForThumbsToAppear);
    } else {
      init();
      update(true);
    }
  });
  on('slideChange update resize observerUpdate', () => {
    update();
  });
  on('setTransition', (_s, duration) => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    thumbsSwiper.setTransition(duration);
  });
  on('beforeDestroy', () => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    if (swiperCreated) {
      thumbsSwiper.destroy();
    }
  });
  Object.assign(swiper.thumbs, {
    init,
    update
  });
}

function freeMode(_ref) {
  let {
    swiper,
    extendParams,
    emit,
    once
  } = _ref;
  extendParams({
    freeMode: {
      enabled: false,
      momentum: true,
      momentumRatio: 1,
      momentumBounce: true,
      momentumBounceRatio: 1,
      momentumVelocityRatio: 1,
      sticky: false,
      minimumVelocity: 0.02
    }
  });
  function onTouchStart() {
    if (swiper.params.cssMode) return;
    const translate = swiper.getTranslate();
    swiper.setTranslate(translate);
    swiper.setTransition(0);
    swiper.touchEventsData.velocities.length = 0;
    swiper.freeMode.onTouchEnd({
      currentPos: swiper.rtl ? swiper.translate : -swiper.translate
    });
  }
  function onTouchMove() {
    if (swiper.params.cssMode) return;
    const {
      touchEventsData: data,
      touches
    } = swiper;
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: now()
    });
  }
  function onTouchEnd(_ref2) {
    let {
      currentPos
    } = _ref2;
    if (swiper.params.cssMode) return;
    const {
      params,
      wrapperEl,
      rtlTranslate: rtl,
      snapGrid,
      touchEventsData: data
    } = swiper;
    // Time diff
    const touchEndTime = now();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }
    if (params.freeMode.momentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();
        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || now() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeMode.momentumVelocityRatio;
      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeMode.momentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;
      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeMode.sticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }
        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        once('transitionEnd', () => {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeMode.sticky) {
          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeMode.sticky) {
        swiper.slideToClosest();
        return;
      }
      if (params.freeMode.momentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        elementTransitionEnd(wrapperEl, () => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            elementTransitionEnd(wrapperEl, () => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          elementTransitionEnd(wrapperEl, () => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeMode.sticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      emit('_freeModeNoMomentumRelease');
    }
    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
      emit('_freeModeStaticRelease');
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
  }
  Object.assign(swiper, {
    freeMode: {
      onTouchStart,
      onTouchMove,
      onTouchEnd
    }
  });
}

function Grid(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    grid: {
      rows: 1,
      fill: 'column'
    }
  });
  let slidesNumberEvenToRows;
  let slidesPerRow;
  let numFullColumns;
  let wasMultiRow;
  const getSpaceBetween = () => {
    let spaceBetween = swiper.params.spaceBetween;
    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
    } else if (typeof spaceBetween === 'string') {
      spaceBetween = parseFloat(spaceBetween);
    }
    return spaceBetween;
  };
  const initSlides = slides => {
    const {
      slidesPerView
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
    numFullColumns = Math.floor(slidesLength / rows);
    if (Math.floor(slidesLength / rows) === slidesLength / rows) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
    }
    if (slidesPerView !== 'auto' && fill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
    }
    slidesPerRow = slidesNumberEvenToRows / rows;
  };
  const unsetSlides = () => {
    if (swiper.slides) {
      swiper.slides.forEach(slide => {
        if (slide.swiperSlideGridSet) {
          slide.style.height = '';
          slide.style[swiper.getDirectionLabel('margin-top')] = '';
        }
      });
    }
  };
  const updateSlide = (i, slide, slides) => {
    const {
      slidesPerGroup
    } = swiper.params;
    const spaceBetween = getSpaceBetween();
    const {
      rows,
      fill
    } = swiper.params.grid;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
    // Set slides order
    let newSlideOrderIndex;
    let column;
    let row;
    if (fill === 'row' && slidesPerGroup > 1) {
      const groupIndex = Math.floor(i / (slidesPerGroup * rows));
      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
      row = Math.floor(slideIndexInGroup / columnsInGroup);
      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
      slide.style.order = newSlideOrderIndex;
    } else if (fill === 'column') {
      column = Math.floor(i / rows);
      row = i - column * rows;
      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
        row += 1;
        if (row >= rows) {
          row = 0;
          column += 1;
        }
      }
    } else {
      row = Math.floor(i / slidesPerRow);
      column = i - row * slidesPerRow;
    }
    slide.row = row;
    slide.column = column;
    slide.style.height = `calc((100% - ${(rows - 1) * spaceBetween}px) / ${rows})`;
    slide.style[swiper.getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';
    slide.swiperSlideGridSet = true;
  };
  const updateWrapperSize = (slideSize, snapGrid) => {
    const {
      centeredSlides,
      roundLengths
    } = swiper.params;
    const spaceBetween = getSpaceBetween();
    const {
      rows
    } = swiper.params.grid;
    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
    if (!swiper.params.cssMode) {
      swiper.wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (centeredSlides) {
      const newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid.splice(0, snapGrid.length);
      snapGrid.push(...newSlidesGrid);
    }
  };
  const onInit = () => {
    wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;
  };
  const onUpdate = () => {
    const {
      params,
      el
    } = swiper;
    const isMultiRow = params.grid && params.grid.rows > 1;
    if (wasMultiRow && !isMultiRow) {
      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
      numFullColumns = 1;
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      el.classList.add(`${params.containerModifierClass}grid`);
      if (params.grid.fill === 'column') {
        el.classList.add(`${params.containerModifierClass}grid-column`);
      }
      swiper.emitContainerClasses();
    }
    wasMultiRow = isMultiRow;
  };
  on('init', onInit);
  on('update', onUpdate);
  swiper.grid = {
    initSlides,
    unsetSlides,
    updateSlide,
    updateWrapperSize
  };
}

function appendSlide(slides) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  const appendElement = slideEl => {
    if (typeof slideEl === 'string') {
      const tempDOM = document.createElement('div');
      tempDOM.innerHTML = slideEl;
      slidesEl.append(tempDOM.children[0]);
      tempDOM.innerHTML = '';
    } else {
      slidesEl.append(slideEl);
    }
  };
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) appendElement(slides[i]);
    }
  } else {
    appendElement(slides);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
}

function prependSlide(slides) {
  const swiper = this;
  const {
    params,
    activeIndex,
    slidesEl
  } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  const prependElement = slideEl => {
    if (typeof slideEl === 'string') {
      const tempDOM = document.createElement('div');
      tempDOM.innerHTML = slideEl;
      slidesEl.prepend(tempDOM.children[0]);
      tempDOM.innerHTML = '';
    } else {
      slidesEl.prepend(slideEl);
    }
  };
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) prependElement(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    prependElement(slides);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

function addSlide(index, slides) {
  const swiper = this;
  const {
    params,
    activeIndex,
    slidesEl
  } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.recalcSlides();
  }
  const baseLength = swiper.slides.length;
  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  const slidesBuffer = [];
  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper.slides[i];
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) slidesEl.append(slides[i]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    slidesEl.append(slides);
  }
  for (let i = 0; i < slidesBuffer.length; i += 1) {
    slidesEl.append(slidesBuffer[i]);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeSlide(slidesIndexes) {
  const swiper = this;
  const {
    params,
    activeIndex
  } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;
  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }
  swiper.recalcSlides();
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer || swiper.isElement) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeAllSlides() {
  const swiper = this;
  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

function Manipulation(_ref) {
  let {
    swiper
  } = _ref;
  Object.assign(swiper, {
    appendSlide: appendSlide.bind(swiper),
    prependSlide: prependSlide.bind(swiper),
    addSlide: addSlide.bind(swiper),
    removeSlide: removeSlide.bind(swiper),
    removeAllSlides: removeAllSlides.bind(swiper)
  });
}

function effectInit(params) {
  const {
    effect,
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams,
    perspective,
    recreateShadows,
    getEffectParams
  } = params;
  on('beforeInit', () => {
    if (swiper.params.effect !== effect) return;
    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
    if (perspective && perspective()) {
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
    }
    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    Object.assign(swiper.params, overwriteParamsResult);
    Object.assign(swiper.originalParams, overwriteParamsResult);
  });
  on('setTranslate', () => {
    if (swiper.params.effect !== effect) return;
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    if (swiper.params.effect !== effect) return;
    setTransition(duration);
  });
  on('transitionEnd', () => {
    if (swiper.params.effect !== effect) return;
    if (recreateShadows) {
      if (!getEffectParams || !getEffectParams().slideShadows) return;
      // remove shadows
      swiper.slides.forEach(slideEl => {
        slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());
      });
      // create new one
      recreateShadows();
    }
  });
  let requireUpdateOnVirtual;
  on('virtualUpdate', () => {
    if (swiper.params.effect !== effect) return;
    if (!swiper.slides.length) {
      requireUpdateOnVirtual = true;
    }
    requestAnimationFrame(() => {
      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
        setTranslate();
        requireUpdateOnVirtual = false;
      }
    });
  });
}

function effectTarget(effectParams, slideEl) {
  const transformEl = getSlideTransformEl(slideEl);
  if (transformEl !== slideEl) {
    transformEl.style.backfaceVisibility = 'hidden';
    transformEl.style['-webkit-backface-visibility'] = 'hidden';
  }
  return transformEl;
}

function effectVirtualTransitionEnd(_ref) {
  let {
    swiper,
    duration,
    transformElements,
    allSlides
  } = _ref;
  const {
    activeIndex
  } = swiper;
  const getSlide = el => {
    if (!el.parentElement) {
      // assume shadow root
      const slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];
      return slide;
    }
    return el.parentElement;
  };
  if (swiper.params.virtualTranslate && duration !== 0) {
    let eventTriggered = false;
    let transitionEndTarget;
    if (allSlides) {
      transitionEndTarget = transformElements;
    } else {
      transitionEndTarget = transformElements.filter(transformEl => {
        const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;
        return swiper.getSlideIndex(el) === activeIndex;
      });
    }
    transitionEndTarget.forEach(el => {
      elementTransitionEnd(el, () => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const evt = new window.CustomEvent('transitionend', {
          bubbles: true,
          cancelable: true
        });
        swiper.wrapperEl.dispatchEvent(evt);
      });
    });
  }
}

function EffectFade(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    fadeEffect: {
      crossFade: false
    }
  });
  const setTranslate = () => {
    const {
      slides
    } = swiper;
    const params = swiper.params.fadeEffect;
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = swiper.slides[i];
      const offset = slideEl.swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.opacity = slideOpacity;
      targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
    });
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements,
      allSlides: true
    });
  };
  effectInit({
    effect: 'fade',
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

function EffectCube(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  });
  const createSlideShadows = (slideEl, progress, isHorizontal) => {
    let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
    let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
    if (!shadowBefore) {
      shadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));
      slideEl.append(shadowBefore);
    }
    if (!shadowAfter) {
      shadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));
      slideEl.append(shadowAfter);
    }
    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    // create new ones
    const isHorizontal = swiper.isHorizontal();
    swiper.slides.forEach(slideEl => {
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      createSlideShadows(slideEl, progress, isHorizontal);
    });
  };
  const setTranslate = () => {
    const {
      el,
      wrapperEl,
      slides,
      width: swiperWidth,
      height: swiperHeight,
      rtlTranslate: rtl,
      size: swiperSize,
      browser
    } = swiper;
    const r = getRotateFix(swiper);
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');
        if (!cubeShadowEl) {
          cubeShadowEl = createElement('div', 'swiper-cube-shadow');
          swiper.wrapperEl.append(cubeShadowEl);
        }
        cubeShadowEl.style.height = `${swiperWidth}px`;
      } else {
        cubeShadowEl = el.querySelector('.swiper-cube-shadow');
        if (!cubeShadowEl) {
          cubeShadowEl = createElement('div', 'swiper-cube-shadow');
          el.append(cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }
      if (rtl) {
        tx = -tx;
      }
      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }
      const transform = `rotateX(${r(isHorizontal ? 0 : -slideAngle)}deg) rotateY(${r(isHorizontal ? slideAngle : 0)}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
      }
      slideEl.style.transform = transform;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress, isHorizontal);
      }
    }
    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;
    wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;
      }
    }
    const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;
    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${r(swiper.isHorizontal() ? 0 : wrapperRotate)}deg) rotateY(${r(swiper.isHorizontal() ? -wrapperRotate : 0)}deg)`;
    wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
  };
  const setTransition = duration => {
    const {
      el,
      slides
    } = swiper;
    slides.forEach(slideEl => {
      slideEl.style.transitionDuration = `${duration}ms`;
      slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {
        subEl.style.transitionDuration = `${duration}ms`;
      });
    });
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      const shadowEl = el.querySelector('.swiper-cube-shadow');
      if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;
    }
  };
  effectInit({
    effect: 'cube',
    swiper,
    on,
    setTranslate,
    setTransition,
    recreateShadows,
    getEffectParams: () => swiper.params.cubeEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: false,
      virtualTranslate: true
    })
  });
}

function createShadow(suffix, slideEl, side) {
  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;
  const shadowContainer = getSlideTransformEl(slideEl);
  let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);
  if (!shadowEl) {
    shadowEl = createElement('div', shadowClass.split(' '));
    shadowContainer.append(shadowEl);
  }
  return shadowEl;
}

function EffectFlip(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    flipEffect: {
      slideShadows: true,
      limitRotation: true
    }
  });
  const createSlideShadows = (slideEl, progress) => {
    let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
    let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
    if (!shadowBefore) {
      shadowBefore = createShadow('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');
    }
    if (!shadowAfter) {
      shadowAfter = createShadow('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
    }
    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    // Set shadows
    swiper.params.flipEffect;
    swiper.slides.forEach(slideEl => {
      let progress = slideEl.progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      createSlideShadows(slideEl, progress);
    });
  };
  const setTranslate = () => {
    const {
      slides,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.flipEffect;
    const rotateFix = getRotateFix(swiper);
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      let progress = slideEl.progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      const offset = slideEl.swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }
      slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress);
      }
      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateFix(rotateX)}deg) rotateY(${rotateFix(rotateY)}deg)`;
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.transform = transform;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements
    });
  };
  effectInit({
    effect: 'flip',
    swiper,
    on,
    setTranslate,
    setTransition,
    recreateShadows,
    getEffectParams: () => swiper.params.flipEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

function EffectCoverflow(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true
    }
  });
  const setTranslate = () => {
    const {
      width: swiperWidth,
      height: swiperHeight,
      slides,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    const r = getRotateFix(swiper);
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const slideEl = slides[i];
      const slideSize = slidesSizesGrid[i];
      const slideOffset = slideEl.swiperSlideOffset;
      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
      const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);
      let stretch = params.stretch;
      // Allow percentage to make a relative stretch for responsive sliders
      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = parseFloat(params.stretch) / 100 * slideSize;
      }
      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;
      if (Math.abs(scale) < 0.001) scale = 0;
      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${r(rotateX)}deg) rotateY(${r(rotateY)}deg) scale(${scale})`;
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.transform = slideTransform;
      slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
        let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
        if (!shadowBeforeEl) {
          shadowBeforeEl = createShadow('coverflow', slideEl, isHorizontal ? 'left' : 'top');
        }
        if (!shadowAfterEl) {
          shadowAfterEl = createShadow('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');
        }
        if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
      }
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
  };
  effectInit({
    effect: 'coverflow',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true
    })
  });
}

function EffectCreative(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    creativeEffect: {
      limitProgress: 1,
      shadowPerProgress: false,
      progressMultiplier: 1,
      perspective: true,
      prev: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      },
      next: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      }
    }
  });
  const getTranslateValue = value => {
    if (typeof value === 'string') return value;
    return `${value}px`;
  };
  const setTranslate = () => {
    const {
      slides,
      wrapperEl,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.creativeEffect;
    const {
      progressMultiplier: multiplier
    } = params;
    const isCenteredSlides = swiper.params.centeredSlides;
    const rotateFix = getRotateFix(swiper);
    if (isCenteredSlides) {
      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
      wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      const slideProgress = slideEl.progress;
      const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);
      let originalProgress = progress;
      if (!isCenteredSlides) {
        originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);
      }
      const offset = slideEl.swiperSlideOffset;
      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
      const r = [0, 0, 0];
      let custom = false;
      if (!swiper.isHorizontal()) {
        t[1] = t[0];
        t[0] = 0;
      }
      let data = {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        scale: 1,
        opacity: 1
      };
      if (progress < 0) {
        data = params.next;
        custom = true;
      } else if (progress > 0) {
        data = params.prev;
        custom = true;
      }
      // set translate
      t.forEach((value, index) => {
        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
      });
      // set rotates
      r.forEach((value, index) => {
        let val = data.rotate[index] * Math.abs(progress * multiplier);
        r[index] = val;
      });
      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const translateString = t.join(', ');
      const rotateString = `rotateX(${rotateFix(r[0])}deg) rotateY(${rotateFix(r[1])}deg) rotateZ(${rotateFix(r[2])}deg)`;
      const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;

      // Set shadows
      if (custom && data.shadow || !custom) {
        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
        if (!shadowEl && data.shadow) {
          shadowEl = createShadow('creative', slideEl);
        }
        if (shadowEl) {
          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
          shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
        }
      }
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.transform = transform;
      targetEl.style.opacity = opacityString;
      if (data.origin) {
        targetEl.style.transformOrigin = data.origin;
      }
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements,
      allSlides: true
    });
  };
  effectInit({
    effect: 'creative',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => swiper.params.creativeEffect.perspective,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

function EffectCards(_ref) {
  let {
    swiper,
    extendParams,
    on
  } = _ref;
  extendParams({
    cardsEffect: {
      slideShadows: true,
      rotate: true,
      perSlideRotate: 2,
      perSlideOffset: 8
    }
  });
  const setTranslate = () => {
    const {
      slides,
      activeIndex,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.cardsEffect;
    const {
      startTranslate,
      isTouched
    } = swiper.touchEventsData;
    const currentTranslate = rtl ? -swiper.translate : swiper.translate;
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      const slideProgress = slideEl.progress;
      const progress = Math.min(Math.max(slideProgress, -4), 4);
      let offset = slideEl.swiperSlideOffset;
      if (swiper.params.centeredSlides && !swiper.params.cssMode) {
        swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
      }
      if (swiper.params.centeredSlides && swiper.params.cssMode) {
        offset -= slides[0].swiperSlideOffset;
      }
      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let tY = 0;
      const tZ = -100 * Math.abs(progress);
      let scale = 1;
      let rotate = -params.perSlideRotate * progress;
      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
      const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
      const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
      const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
      if (isSwipeToNext || isSwipeToPrev) {
        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
        rotate += -28 * progress * subProgress;
        scale += -0.5 * subProgress;
        tXAdd += 96 * subProgress;
        tY = `${-25 * subProgress * Math.abs(progress)}%`;
      }
      if (progress < 0) {
        // next
        tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;
      } else if (progress > 0) {
        // prev
        tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;
      } else {
        tX = `${tX}px`;
      }
      if (!swiper.isHorizontal()) {
        const prevY = tY;
        tY = tX;
        tX = prevY;
      }
      const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;

      /* eslint-disable */
      const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)
        scale(${scaleString})
      `;
      /* eslint-enable */

      if (params.slideShadows) {
        // Set shadows
        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
        if (!shadowEl) {
          shadowEl = createShadow('cards', slideEl);
        }
        if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
      }
      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.transform = transform;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements
    });
  };
  effectInit({
    effect: 'cards',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

/**
 * Swiper 11.1.14
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2024 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: September 12, 2024
 */


// Swiper Class
const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
Swiper.use(modules);

/* underscore in name -> watch for changes */
const paramsList = ['eventsPrefix', 'injectStyles', 'injectStylesUrls', 'modules', 'init', '_direction', 'oneWayMovement', 'swiperElementNodeName', 'touchEventsTarget', 'initialSlide', '_speed', 'cssMode', 'updateOnWindowResize', 'resizeObserver', 'nested', 'focusableElements', '_enabled', '_width', '_height', 'preventInteractionOnTransition', 'userAgent', 'url', '_edgeSwipeDetection', '_edgeSwipeThreshold', '_freeMode', '_autoHeight', 'setWrapperSize', 'virtualTranslate', '_effect', 'breakpoints', 'breakpointsBase', '_spaceBetween', '_slidesPerView', 'maxBackfaceHiddenSlides', '_grid', '_slidesPerGroup', '_slidesPerGroupSkip', '_slidesPerGroupAuto', '_centeredSlides', '_centeredSlidesBounds', '_slidesOffsetBefore', '_slidesOffsetAfter', 'normalizeSlideIndex', '_centerInsufficientSlides', '_watchOverflow', 'roundLengths', 'touchRatio', 'touchAngle', 'simulateTouch', '_shortSwipes', '_longSwipes', 'longSwipesRatio', 'longSwipesMs', '_followFinger', 'allowTouchMove', '_threshold', 'touchMoveStopPropagation', 'touchStartPreventDefault', 'touchStartForcePreventDefault', 'touchReleaseOnEdges', 'uniqueNavElements', '_resistance', '_resistanceRatio', '_watchSlidesProgress', '_grabCursor', 'preventClicks', 'preventClicksPropagation', '_slideToClickedSlide', '_loop', 'loopAdditionalSlides', 'loopAddBlankSlides', 'loopPreventsSliding', '_rewind', '_allowSlidePrev', '_allowSlideNext', '_swipeHandler', '_noSwiping', 'noSwipingClass', 'noSwipingSelector', 'passiveListeners', 'containerModifierClass', 'slideClass', 'slideActiveClass', 'slideVisibleClass', 'slideFullyVisibleClass', 'slideNextClass', 'slidePrevClass', 'slideBlankClass', 'wrapperClass', 'lazyPreloaderClass', 'lazyPreloadPrevNext', 'runCallbacksOnInit', 'observer', 'observeParents', 'observeSlideChildren',
// modules
'a11y', '_autoplay', '_controller', 'coverflowEffect', 'cubeEffect', 'fadeEffect', 'flipEffect', 'creativeEffect', 'cardsEffect', 'hashNavigation', 'history', 'keyboard', 'mousewheel', '_navigation', '_pagination', 'parallax', '_scrollbar', '_thumbs', 'virtual', 'zoom', 'control'];

function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object' && !o.__swiper__;
}
function extend(target, src) {
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__) target[key] = src[key];else extend(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}
function needsNavigation(params) {
  if (params === void 0) {
    params = {};
  }
  return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';
}
function needsPagination(params) {
  if (params === void 0) {
    params = {};
  }
  return params.pagination && typeof params.pagination.el === 'undefined';
}
function needsScrollbar(params) {
  if (params === void 0) {
    params = {};
  }
  return params.scrollbar && typeof params.scrollbar.el === 'undefined';
}
function attrToProp(attrName) {
  if (attrName === void 0) {
    attrName = '';
  }
  return attrName.replace(/-[a-z]/g, l => l.toUpperCase().replace('-', ''));
}

function updateSwiper(_ref) {
  let {
    swiper,
    slides,
    passedParams,
    changedParams,
    nextEl,
    prevEl,
    scrollbarEl,
    paginationEl
  } = _ref;
  const updateParams = changedParams.filter(key => key !== 'children' && key !== 'direction' && key !== 'wrapperClass');
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;
  let loopNeedDestroy;
  let loopNeedEnable;
  let loopNeedReloop;
  if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }
  if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }
  if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }
  if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }
  if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }
  const destroyModule = mod => {
    if (!swiper[mod]) return;
    swiper[mod].destroy();
    if (mod === 'navigation') {
      if (swiper.isElement) {
        swiper[mod].prevEl.remove();
        swiper[mod].nextEl.remove();
      }
      currentParams[mod].prevEl = undefined;
      currentParams[mod].nextEl = undefined;
      swiper[mod].prevEl = undefined;
      swiper[mod].nextEl = undefined;
    } else {
      if (swiper.isElement) {
        swiper[mod].el.remove();
      }
      currentParams[mod].el = undefined;
      swiper[mod].el = undefined;
    }
  };
  if (changedParams.includes('loop') && swiper.isElement) {
    if (currentParams.loop && !passedParams.loop) {
      loopNeedDestroy = true;
    } else if (!currentParams.loop && passedParams.loop) {
      loopNeedEnable = true;
    } else {
      loopNeedReloop = true;
    }
  }
  updateParams.forEach(key => {
    if (isObject(currentParams[key]) && isObject(passedParams[key])) {
      Object.assign(currentParams[key], passedParams[key]);
      if ((key === 'navigation' || key === 'pagination' || key === 'scrollbar') && 'enabled' in passedParams[key] && !passedParams[key].enabled) {
        destroyModule(key);
      }
    } else {
      const newValue = passedParams[key];
      if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });
  if (updateParams.includes('controller') && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (changedParams.includes('children') && slides && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  } else if (changedParams.includes('virtual') && virtual && currentParams.virtual.enabled) {
    if (slides) virtual.slides = slides;
    virtual.update(true);
  }
  if (changedParams.includes('children') && slides && currentParams.loop) {
    loopNeedReloop = true;
  }
  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized) thumbs.update(true);
  }
  if (needControllerInit) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (needPaginationInit) {
    if (swiper.isElement && (!paginationEl || typeof paginationEl === 'string')) {
      paginationEl = document.createElement('div');
      paginationEl.classList.add('swiper-pagination');
      paginationEl.part.add('pagination');
      swiper.el.appendChild(paginationEl);
    }
    if (paginationEl) currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }
  if (needScrollbarInit) {
    if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === 'string')) {
      scrollbarEl = document.createElement('div');
      scrollbarEl.classList.add('swiper-scrollbar');
      scrollbarEl.part.add('scrollbar');
      swiper.el.appendChild(scrollbarEl);
    }
    if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }
  if (needNavigationInit) {
    if (swiper.isElement) {
      if (!nextEl || typeof nextEl === 'string') {
        nextEl = document.createElement('div');
        nextEl.classList.add('swiper-button-next');
        nextEl.innerHTML = swiper.hostEl.constructor.nextButtonSvg;
        nextEl.part.add('button-next');
        swiper.el.appendChild(nextEl);
      }
      if (!prevEl || typeof prevEl === 'string') {
        prevEl = document.createElement('div');
        prevEl.classList.add('swiper-button-prev');
        prevEl.innerHTML = swiper.hostEl.constructor.prevButtonSvg;
        prevEl.part.add('button-prev');
        swiper.el.appendChild(prevEl);
      }
    }
    if (nextEl) currentParams.navigation.nextEl = nextEl;
    if (prevEl) currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }
  if (changedParams.includes('allowSlideNext')) {
    swiper.allowSlideNext = passedParams.allowSlideNext;
  }
  if (changedParams.includes('allowSlidePrev')) {
    swiper.allowSlidePrev = passedParams.allowSlidePrev;
  }
  if (changedParams.includes('direction')) {
    swiper.changeDirection(passedParams.direction, false);
  }
  if (loopNeedDestroy || loopNeedReloop) {
    swiper.loopDestroy();
  }
  if (loopNeedEnable || loopNeedReloop) {
    swiper.loopCreate();
  }
  swiper.update();
}

const formatValue = val => {
  if (parseFloat(val) === Number(val)) return Number(val);
  if (val === 'true') return true;
  if (val === '') return true;
  if (val === 'false') return false;
  if (val === 'null') return null;
  if (val === 'undefined') return undefined;
  if (typeof val === 'string' && val.includes('{') && val.includes('}') && val.includes('"')) {
    let v;
    try {
      v = JSON.parse(val);
    } catch (err) {
      v = val;
    }
    return v;
  }
  return val;
};
const modulesParamsList = ['a11y', 'autoplay', 'controller', 'cards-effect', 'coverflow-effect', 'creative-effect', 'cube-effect', 'fade-effect', 'flip-effect', 'free-mode', 'grid', 'hash-navigation', 'history', 'keyboard', 'mousewheel', 'navigation', 'pagination', 'parallax', 'scrollbar', 'thumbs', 'virtual', 'zoom'];
function getParams(element, propName, propValue) {
  const params = {};
  const passedParams = {};
  extend(params, defaults);
  const localParamsList = [...paramsList, 'on'];
  const allowedParams = localParamsList.map(key => key.replace(/_/, ''));

  // First check props
  localParamsList.forEach(paramName => {
    paramName = paramName.replace('_', '');
    if (typeof element[paramName] !== 'undefined') {
      passedParams[paramName] = element[paramName];
    }
  });

  // Attributes
  const attrsList = [...element.attributes];
  if (typeof propName === 'string' && typeof propValue !== 'undefined') {
    attrsList.push({
      name: propName,
      value: isObject(propValue) ? {
        ...propValue
      } : propValue
    });
  }
  attrsList.forEach(attr => {
    const moduleParam = modulesParamsList.filter(mParam => attr.name.indexOf(`${mParam}-`) === 0)[0];
    if (moduleParam) {
      const parentObjName = attrToProp(moduleParam);
      const subObjName = attrToProp(attr.name.split(`${moduleParam}-`)[1]);
      if (typeof passedParams[parentObjName] === 'undefined') passedParams[parentObjName] = {};
      if (passedParams[parentObjName] === true) {
        passedParams[parentObjName] = {
          enabled: true
        };
      }
      passedParams[parentObjName][subObjName] = formatValue(attr.value);
    } else {
      const name = attrToProp(attr.name);
      if (!allowedParams.includes(name)) return;
      const value = formatValue(attr.value);
      if (passedParams[name] && modulesParamsList.includes(attr.name) && !isObject(value)) {
        if (passedParams[name].constructor !== Object) {
          passedParams[name] = {};
        }
        passedParams[name].enabled = !!value;
      } else {
        passedParams[name] = value;
      }
    }
  });
  extend(params, passedParams);
  if (params.navigation) {
    params.navigation = {
      prevEl: '.swiper-button-prev',
      nextEl: '.swiper-button-next',
      ...(params.navigation !== true ? params.navigation : {})
    };
  } else if (params.navigation === false) {
    delete params.navigation;
  }
  if (params.scrollbar) {
    params.scrollbar = {
      el: '.swiper-scrollbar',
      ...(params.scrollbar !== true ? params.scrollbar : {})
    };
  } else if (params.scrollbar === false) {
    delete params.scrollbar;
  }
  if (params.pagination) {
    params.pagination = {
      el: '.swiper-pagination',
      ...(params.pagination !== true ? params.pagination : {})
    };
  } else if (params.pagination === false) {
    delete params.pagination;
  }
  return {
    params,
    passedParams
  };
}

/**
 * Swiper Custom Element 11.1.14
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2024 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: September 12, 2024
 */


/* eslint-disable spaced-comment */

const SwiperCSS = `:host{--swiper-theme-color:#007aff}:host{position:relative;display:block;margin-left:auto;margin-right:auto;z-index:1}.swiper{width:100%;height:100%;margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}.swiper-android ::slotted(swiper-slide),.swiper-ios ::slotted(swiper-slide),.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}::slotted(swiper-slide){flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}::slotted(.swiper-slide-invisible-blank){visibility:hidden}.swiper-autoheight,.swiper-autoheight ::slotted(swiper-slide){height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden ::slotted(swiper-slide){transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d ::slotted(swiper-slide){transform-style:preserve-3d}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode ::slotted(swiper-slide){scroll-snap-align:start start}.swiper-css-mode.swiper-horizontal>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-css-mode.swiper-vertical>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode ::slotted(swiper-slide){scroll-snap-align:none}.swiper-css-mode.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-css-mode.swiper-centered ::slotted(swiper-slide){scroll-snap-align:center center;scroll-snap-stop:always}.swiper-css-mode.swiper-centered.swiper-horizontal ::slotted(swiper-slide):first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-css-mode.swiper-centered.swiper-vertical ::slotted(swiper-slide):first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-virtual ::slotted(swiper-slide){-webkit-backface-visibility:hidden;transform:translateZ(0)}.swiper-virtual.swiper-css-mode .swiper-wrapper::after{content:'';position:absolute;left:0;top:0;pointer-events:none}.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after{height:1px;width:var(--swiper-virtual-size)}.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after{width:1px;height:var(--swiper-virtual-size)}:host{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:var(--swiper-navigation-top-offset,50%);width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next svg,.swiper-button-prev svg{width:100%;height:100%;object-fit:contain;transform-origin:center}.swiper-rtl .swiper-button-next svg,.swiper-rtl .swiper-button-prev svg{transform:rotate(180deg)}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:var(--swiper-navigation-sides-offset,10px);right:auto}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:var(--swiper-navigation-sides-offset,10px);left:auto}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:var(--swiper-pagination-bottom,8px);top:var(--swiper-pagination-top,auto);left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:var(--swiper-pagination-bullet-border-radius,50%);background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:var(--swiper-pagination-right,8px);left:var(--swiper-pagination-left,auto);top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color,inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color,rgba(0,0,0,.25));position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:var(--swiper-pagination-progressbar-size,4px);left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:var(--swiper-pagination-progressbar-size,4px);height:100%;left:0;top:0}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:var(--swiper-scrollbar-border-radius,10px);position:relative;touch-action:none;background:var(--swiper-scrollbar-bg-color,rgba(0,0,0,.1))}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:var(--swiper-scrollbar-sides-offset,1%);bottom:var(--swiper-scrollbar-bottom,4px);top:var(--swiper-scrollbar-top,auto);z-index:50;height:var(--swiper-scrollbar-size,4px);width:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;left:var(--swiper-scrollbar-left,auto);right:var(--swiper-scrollbar-right,4px);top:var(--swiper-scrollbar-sides-offset,1%);z-index:50;width:var(--swiper-scrollbar-size,4px);height:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:var(--swiper-scrollbar-drag-bg-color,rgba(0,0,0,.5));border-radius:var(--swiper-scrollbar-border-radius,10px);left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}::slotted(.swiper-slide-zoomed){cursor:move;touch-action:none}.swiper .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}.swiper-grid>.swiper-wrapper{flex-wrap:wrap}.swiper-grid-column>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-fade.swiper-free-mode ::slotted(swiper-slide){transition-timing-function:ease-out}.swiper-fade ::slotted(swiper-slide){pointer-events:none;transition-property:opacity}.swiper-fade ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-fade ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-fade ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper.swiper-cube{overflow:visible}.swiper-cube ::slotted(swiper-slide){pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-cube ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-cube.swiper-rtl ::slotted(swiper-slide){transform-origin:100% 0}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-next),.swiper-cube ::slotted(.swiper-slide-prev){pointer-events:auto;visibility:visible}.swiper-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;filter:blur(50px)}.swiper-cube ::slotted(.swiper-slide-next)+::slotted(swiper-slide){pointer-events:auto;visibility:visible}.swiper.swiper-flip{overflow:visible}.swiper-flip ::slotted(swiper-slide){pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-flip ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-flip ::slotted(.swiper-slide-active),.swiper-flip ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-creative ::slotted(swiper-slide){-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper.swiper-cards{overflow:visible}.swiper-cards ::slotted(swiper-slide){transform-origin:center bottom;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden}`;
const SwiperSlideCSS = `::slotted(.swiper-slide-shadow),::slotted(.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-top){position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}::slotted(.swiper-slide-shadow){background:rgba(0,0,0,.15)}::slotted(.swiper-slide-shadow-left){background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-right){background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-top){background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-bottom){background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear;width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-top){z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-top){z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}::slotted(.swiper-zoom-container){width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}::slotted(.swiper-zoom-container)>canvas,::slotted(.swiper-zoom-container)>img,::slotted(.swiper-zoom-container)>svg{max-width:100%;max-height:100%;object-fit:contain}`;

class DummyHTMLElement {}
const ClassToExtend = typeof window === 'undefined' || typeof HTMLElement === 'undefined' ? DummyHTMLElement : HTMLElement;
const arrowSvg = `<svg width="11" height="20" viewBox="0 0 11 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.38296 20.0762C0.111788 19.805 0.111788 19.3654 0.38296 19.0942L9.19758 10.2796L0.38296 1.46497C0.111788 1.19379 0.111788 0.754138 0.38296 0.482966C0.654131 0.211794 1.09379 0.211794 1.36496 0.482966L10.4341 9.55214C10.8359 9.9539 10.8359 10.6053 10.4341 11.007L1.36496 20.0762C1.09379 20.3474 0.654131 20.3474 0.38296 20.0762Z" fill="currentColor"/></svg>
    `;
const addStyle = (shadowRoot, styles) => {
  if (typeof CSSStyleSheet !== 'undefined' && shadowRoot.adoptedStyleSheets) {
    const styleSheet = new CSSStyleSheet();
    styleSheet.replaceSync(styles);
    shadowRoot.adoptedStyleSheets = [styleSheet];
  } else {
    const style = document.createElement('style');
    style.rel = 'stylesheet';
    style.textContent = styles;
    shadowRoot.appendChild(style);
  }
};
class SwiperContainer extends ClassToExtend {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  static get nextButtonSvg() {
    return arrowSvg;
  }
  static get prevButtonSvg() {
    return arrowSvg.replace('/></svg>', ' transform-origin="center" transform="rotate(180)"/></svg>');
  }
  cssStyles() {
    return [SwiperCSS,
    // eslint-disable-line
    ...(this.injectStyles && Array.isArray(this.injectStyles) ? this.injectStyles : [])].join('\n');
  }
  cssLinks() {
    return this.injectStylesUrls || [];
  }
  calcSlideSlots() {
    const currentSideSlots = this.slideSlots || 0;
    // slide slots
    const slideSlotChildren = [...this.querySelectorAll(`[slot^=slide-]`)].map(child => {
      return parseInt(child.getAttribute('slot').split('slide-')[1], 10);
    });
    this.slideSlots = slideSlotChildren.length ? Math.max(...slideSlotChildren) + 1 : 0;
    if (!this.rendered) return;
    if (this.slideSlots > currentSideSlots) {
      for (let i = currentSideSlots; i < this.slideSlots; i += 1) {
        const slideEl = document.createElement('swiper-slide');
        slideEl.setAttribute('part', `slide slide-${i + 1}`);
        const slotEl = document.createElement('slot');
        slotEl.setAttribute('name', `slide-${i + 1}`);
        slideEl.appendChild(slotEl);
        this.shadowRoot.querySelector('.swiper-wrapper').appendChild(slideEl);
      }
    } else if (this.slideSlots < currentSideSlots) {
      const slides = this.swiper.slides;
      for (let i = slides.length - 1; i >= 0; i -= 1) {
        if (i > this.slideSlots) {
          slides[i].remove();
        }
      }
    }
  }
  render() {
    if (this.rendered) return;
    this.calcSlideSlots();

    // local styles
    let localStyles = this.cssStyles();
    if (this.slideSlots > 0) {
      localStyles = localStyles.replace(/::slotted\(([a-z-0-9.]*)\)/g, '$1');
    }
    if (localStyles.length) {
      addStyle(this.shadowRoot, localStyles);
    }
    this.cssLinks().forEach(url => {
      const linkExists = this.shadowRoot.querySelector(`link[href="${url}"]`);
      if (linkExists) return;
      const linkEl = document.createElement('link');
      linkEl.rel = 'stylesheet';
      linkEl.href = url;
      this.shadowRoot.appendChild(linkEl);
    });
    // prettier-ignore
    const el = document.createElement('div');
    el.classList.add('swiper');
    el.part = 'container';

    // prettier-ignore
    el.innerHTML = `
      <slot name="container-start"></slot>
      <div class="swiper-wrapper" part="wrapper">
        <slot></slot>
        ${Array.from({
      length: this.slideSlots
    }).map((_, index) => `
        <swiper-slide part="slide slide-${index}">
          <slot name="slide-${index}"></slot>
        </swiper-slide>
        `).join('')}
      </div>
      <slot name="container-end"></slot>
      ${needsNavigation(this.passedParams) ? `
        <div part="button-prev" class="swiper-button-prev">${this.constructor.prevButtonSvg}</div>
        <div part="button-next" class="swiper-button-next">${this.constructor.nextButtonSvg}</div>
      ` : ''}
      ${needsPagination(this.passedParams) ? `
        <div part="pagination" class="swiper-pagination"></div>
      ` : ''}
      ${needsScrollbar(this.passedParams) ? `
        <div part="scrollbar" class="swiper-scrollbar"></div>
      ` : ''}
    `;
    this.shadowRoot.appendChild(el);
    this.rendered = true;
  }
  initialize() {
    var _this = this;
    if (this.initialized) return;
    this.initialized = true;
    const {
      params: swiperParams,
      passedParams
    } = getParams(this);
    this.swiperParams = swiperParams;
    this.passedParams = passedParams;
    delete this.swiperParams.init;
    this.render();

    // eslint-disable-next-line
    this.swiper = new Swiper(this.shadowRoot.querySelector('.swiper'), {
      ...(swiperParams.virtual ? {} : {
        observer: true
      }),
      ...swiperParams,
      touchEventsTarget: 'container',
      onAny: function (name) {
        if (name === 'observerUpdate') {
          _this.calcSlideSlots();
        }
        const eventName = swiperParams.eventsPrefix ? `${swiperParams.eventsPrefix}${name.toLowerCase()}` : name.toLowerCase();
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        const event = new CustomEvent(eventName, {
          detail: args,
          bubbles: name !== 'hashChange',
          cancelable: true
        });
        _this.dispatchEvent(event);
      }
    });
  }
  connectedCallback() {
    if (this.initialized && this.nested && this.closest('swiper-slide') && this.closest('swiper-slide').swiperLoopMoveDOM) {
      return;
    }
    if (this.init === false || this.getAttribute('init') === 'false') {
      return;
    }
    this.initialize();
  }
  disconnectedCallback() {
    if (this.nested && this.closest('swiper-slide') && this.closest('swiper-slide').swiperLoopMoveDOM) {
      return;
    }
    if (this.swiper && this.swiper.destroy) {
      this.swiper.destroy();
    }
    this.initialized = false;
  }
  updateSwiperOnPropChange(propName, propValue) {
    const {
      params: swiperParams,
      passedParams
    } = getParams(this, propName, propValue);
    this.passedParams = passedParams;
    this.swiperParams = swiperParams;
    if (this.swiper && this.swiper.params[propName] === propValue) {
      return;
    }
    updateSwiper({
      swiper: this.swiper,
      passedParams: this.passedParams,
      changedParams: [attrToProp(propName)],
      ...(propName === 'navigation' && passedParams[propName] ? {
        prevEl: '.swiper-button-prev',
        nextEl: '.swiper-button-next'
      } : {}),
      ...(propName === 'pagination' && passedParams[propName] ? {
        paginationEl: '.swiper-pagination'
      } : {}),
      ...(propName === 'scrollbar' && passedParams[propName] ? {
        scrollbarEl: '.swiper-scrollbar'
      } : {})
    });
  }
  attributeChangedCallback(attr, prevValue, newValue) {
    if (!this.initialized) return;
    if (prevValue === 'true' && newValue === null) {
      newValue = false;
    }
    this.updateSwiperOnPropChange(attr, newValue);
  }
  static get observedAttributes() {
    const attrs = paramsList.filter(param => param.includes('_')).map(param => param.replace(/[A-Z]/g, v => `-${v}`).replace('_', '').toLowerCase());
    return attrs;
  }
}
paramsList.forEach(paramName => {
  if (paramName === 'init') return;
  paramName = paramName.replace('_', '');
  Object.defineProperty(SwiperContainer.prototype, paramName, {
    configurable: true,
    get() {
      return (this.passedParams || {})[paramName];
    },
    set(value) {
      if (!this.passedParams) this.passedParams = {};
      this.passedParams[paramName] = value;
      if (!this.initialized) return;
      this.updateSwiperOnPropChange(paramName, value);
    }
  });
});
class SwiperSlide extends ClassToExtend {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  render() {
    const lazy = this.lazy || this.getAttribute('lazy') === '' || this.getAttribute('lazy') === 'true';
    addStyle(this.shadowRoot, SwiperSlideCSS);
    this.shadowRoot.appendChild(document.createElement('slot'));
    if (lazy) {
      const lazyDiv = document.createElement('div');
      lazyDiv.classList.add('swiper-lazy-preloader');
      lazyDiv.part.add('preloader');
      this.shadowRoot.appendChild(lazyDiv);
    }
  }
  initialize() {
    this.render();
  }
  connectedCallback() {
    this.initialize();
  }
}

// eslint-disable-next-line
const register = () => {
  if (typeof window === 'undefined') return;
  if (!window.customElements.get('swiper-container')) window.customElements.define('swiper-container', SwiperContainer);
  if (!window.customElements.get('swiper-slide')) window.customElements.define('swiper-slide', SwiperSlide);
};
if (typeof window !== 'undefined') {
  window.SwiperElementRegisterParams = params => {
    paramsList.push(...params);
  };
}

let isSwiperRegistered = false;
if (!isSwiperRegistered) {
    register();
    isSwiperRegistered = true;
}
function loadControlTiles(tilesConfig, hass, isTablet) {
    const controlTiles = [];
    const controlColumns = [];
    let currentPage = [];
    let firstTile = true;
    for (const config of tilesConfig) {
        if (firstTile) {
            const columns = config.type === 'page' &&
                config.columns >= 2 &&
                config.columns <= 4
                ? config.columns
                : 3;
            controlColumns.push(columns);
        }
        if (config.type === 'page') {
            if (!firstTile && currentPage.length) {
                controlTiles.push(currentPage);
                currentPage = [];
                const columns = config.type === 'page' &&
                    config.columns >= 2 &&
                    config.columns <= 4
                    ? config.columns
                    : 3;
                controlColumns.push(columns);
            }
        }
        else if (config.type === 'blank') {
            if (isTablet) {
                const blankTile = document.createElement('div');
                blankTile.classList.add('blank-tile');
                currentPage.push(blankTile);
            }
        }
        else {
            const tile = createElement$1(config, hass);
            if (tile) {
                currentPage.push(tile);
            }
            else {
                console.error('Failed to create tile for config:', config);
            }
        }
        firstTile = false;
    }
    if (currentPage.length > 0) {
        controlTiles.push(currentPage);
    }
    return { controlTiles, controlColumns };
}
function renderControls(controlTiles, controlColumns, isPhone) {
    if (controlTiles.length === 0)
        return E;
    if (isPhone) {
        const gridStyle = { gridTemplateColumns: 'repeat(2, minmax(0, 1fr))' };
        return x `
            <div class="control-tiles" style=${o(gridStyle)}>
                ${controlTiles.flat().map((tile) => x `${tile}`)}
            </div>
        `;
    }
    if (controlTiles.length === 1) {
        const gridStyle = {
            gridTemplateColumns: `repeat(${controlColumns[0]}, var(--sq-tile-width, 19.5rem))`,
        };
        return x `
            <div class="control-slide">
                <div class="control-tiles" style=${o(gridStyle)}>
                    ${controlTiles[0].map((tile) => x ` <div class="tile">${tile}</div> `)}
                </div>
            </div>
        `;
    }
    return x `
        <swiper-container
            .initialSlide=${0}
            .loop=${true}
            .mousewheel=${true}
            .navigation=${true}
            class="control-container"
        >
            ${controlTiles.map((page, index) => {
        const gridStyle = {
            gridTemplateColumns: `repeat(${controlColumns[index]}, var(--sq-tile-width, 19.5rem))`,
        };
        return x `
                    <swiper-slide class="control-slide">
                        <div class="control-tiles" style=${o(gridStyle)}>
                            ${page.map((tile) => x `<div class="tile">${tile}</div>`)}
                        </div>
                    </swiper-slide>
                `;
    })}
            <div class="swiper-button-prev"></div>
            <div class="swiper-button-next"></div>
        </swiper-container>
    `;
}

const styles = i`:host {
    max-width: 100vw;
}
.panel {
    display: grid;
    height: 100vh;
    background-color: var(--sq-panel-color);
    background-attachment: fixed;
    background-position: center;
    background-repeat: no-repeat;
    background-size: cover;
    grid-template-columns: 100%;
    grid-template-rows: auto auto minmax(0, 1fr) auto;
    grid-template-areas:
        'header'
        'area'
        'swiper'
        'footer';
    gap: 2rem;
    padding: 1rem 1rem 0.5rem 1rem;
    box-sizing: border-box;
}
.panel[admin] {
    height: calc(100vh - 56px);
}

.header-container {
    grid-area: header;
    display: flex;
    justify-content: space-between;
}
.header-time-date {
    display: flex;
    flex-direction: column;
    cursor: pointer;
}
.time,
.date {
    text-align: left;
    white-space: nowrap;
}
.time {
    line-height: 3rem;
    font-size: var(--sq-title-font-size);
    font-weight: var(--sq-title-font-weight);
    color: rgb(var(--sq-title-font-rgb));
}
.date {
    margin-top: 0.4rem;
    font-size: var(--sq-primary-font-size);
    font-weight: var(--sq-primary-font-weight);
    color: rgb(var(--sq-secondary-font-rgb));
}
.header-chips {
    display: flex;
    margin-right: calc(var(--sq-chip-spacing) * -1);
    justify-content: flex-end;
}
.chip {
    display: flex;
}
.area-container {
    grid-area: area;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows:
        min-content
        1fr;
    grid-template-areas:
        'name image'
        'chips image';
}
.area-name {
    grid-area: name;
    line-height: normal;
    text-align: left;
    font-size: var(--sq-title-font-size);
    font-weight: var(--sq-title-font-weight);
    color: rgb(var(--sq-title-font-rgb));
}
.area-chips {
    grid-area: chips;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-start;
    margin-left: calc(var(--sq-chip-spacing) * -1);
}
.area-picture {
    grid-area: image;
    width: 100%;
    height: 20vh;
    object-fit: cover;
    border-radius: 0.2rem;
    border: none;
    box-shadow: none;
    background-color: transparent;
}

.control-container {
    grid-area: swiper;
    width: 100%;
}
.control-slide {
    height: 100%;
    align-content: center;
    overflow-y: auto;
}
.control-tiles {
    display: grid;
    width: min-content;
    margin: 0 auto;
    grid-auto-rows: var(--sq-tile-height);
    gap: var(--sq-tile-spacing);
    overflow-y: auto;
}
.blank-tile {
    visibility: hidden;
    width: 100%;
    height: 100%;
}
.footer-container {
    display: flex;
    gap: 5rem;
    justify-content: center;
    align-items: center;
}
.footer-icon {
    height: var(--sq-icon-size);
    width: var(--sq-icon-size);
}
.footer-button {
    display: flex;
    gap: 0.5rem;
    padding: 1rem;
    align-items: center;
    justify-content: center;
    font-size: var(--sq-primary-font-size);
    font-weight: var(--sq-primary-font-weight);
    color: rgb(var(--sq-secondary-font-rgb));
    cursor: pointer;
}

/* Tablet Portrait */
@media (orientation: portrait) and (min-width: 601px),
    (orientation: portrait) and (width: 534px) {
    .area-picture {
        height: 10vh;
    }
}

/* Phone Portrait */
@media (orientation: portrait) and (max-width: 534px),
    (orientation: portrait) and (min-width: 535px) and (max-width: 600px) {
    .panel {
        grid-template-rows:
            auto
            minmax(0, 1fr)
            auto;
        grid-template-areas:
            'area'
            'body'
            'footer';
        gap: 1rem;
        padding: 0.6rem 0.6rem 0.3rem 0.6rem;
    }
    .area-container {
        grid-template-columns: 1fr;
        grid-template-rows:
            auto
            auto;
        grid-template-areas:
            'image'
            'chips';
        gap: 1rem;
        position: relative;
    }
    .area-picture {
        height: 15vh;
    }
    .area-name.overlay {
        position: absolute;
        top: 0;
        left: 0;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 0.5rem;
        font-size: 2.5rem;
        font-weight: var(--sq-title-font-weight);
        border-radius: 0.2rem 0 0 0;
    }
    .control-container {
        grid-area: body;
        display: flex;
        width: 100%;
        overflow-y: auto;
    }
    .control-tiles {
        width: 100%;
        margin: 0;
        gap: var(--sq-tile-spacing);
    }
    .footer-button span {
        display: none;
    }
}
/* Phone Landscape */
@media (orientation: landscape) and (max-height: 534px),
    (orientation: landscape) and (min-height: 535px) and (max-height: 600px) {
    .panel {
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 100%;
        grid-template-areas: 'area body';
        gap: 1rem;
        padding: 0.6rem 0.6rem 0.3rem 0.6rem;
    }
    .area-container {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
        grid-template-areas:
            'image'
            'chips'
            'footer-p-l';
        gap: 1rem;
        position: relative;
    }
    .area-picture {
        height: 35vh;
    }
    .area-name.overlay {
        position: absolute;
        top: 0;
        left: 0;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 0.5rem;
        font-size: 2.5rem;
        font-weight: var(--sq-title-font-weight);
        border-radius: 0.2rem 0 0 0;
    }
    .area-chips {
        align-items: flex-start;
    }
    .footer-container {
        grid-area: footer-p-l;
        display: flex;
        gap: 3rem;
        justify-content: center;
        align-items: center;
    }
    .footer-button span {
        display: none;
    }
    .control-container {
        grid-area: body;
        display: flex;
        width: 100%;
        overflow-y: auto;
    }
    .control-tiles {
        width: 100%;
        margin: 0;
        gap: var(--sq-tile-spacing);
    }
}
`;

window.customCards.push({
    type: 'smartqasa-panel-card',
    name: 'SmartQasa Panel Card',
    preview: true,
    description: 'A SmartQasa card for rendering a panel.',
});
let PanelCard = class PanelCard extends r$1 {
    constructor() {
        super(...arguments);
        this._isAdminMode = false;
        this._isPhone = getDeviceType() === 'phone';
        this._isTablet = getDeviceType() === 'tablet';
        this._isPortrait = getDeviceOrientation() === 'portrait';
        this._isLandscape = getDeviceOrientation() === 'landscape';
        this._boundHandleDeviceChanges = () => this._handleDeviceChanges();
        this._boundStartDashboardTimer = () => this._startDashboardTimer();
        this._areaChips = [];
        this._controlTiles = [];
        this._controlColumns = [];
    }
    getCardSize() {
        return 100;
    }
    static get styles() {
        return r$2(styles);
    }
    setConfig(config) {
        this._config = config;
        this._area = this._config.area;
    }
    connectedCallback() {
        super.connectedCallback();
        this._timeIntervalId = setInterval(() => {
            if (document.visibilityState === 'visible') {
                this.requestUpdate();
            }
        }, 1000);
        window.addEventListener('resize', this._boundHandleDeviceChanges);
        window.addEventListener('orientationchange', this._boundHandleDeviceChanges);
        window.addEventListener('touchstart', this._boundStartDashboardTimer, {
            passive: true,
        });
        this._startDashboardTimer();
    }
    willUpdate(changedProps) {
        super.willUpdate(changedProps);
        if (changedProps.has('_config')) {
            this._loadContent();
        }
        if (changedProps.has('hass') && this.hass) {
            this._handleBackgroundChange();
            this._isAdminMode =
                (this.hass.user?.is_admin ?? false) ||
                    this.hass.states['input_boolean.admin_mode']?.state === 'on';
            this._areaObj = this._area
                ? this.hass?.areas[this._area]
                : undefined;
        }
    }
    render() {
        if (!this.hass || !this._config || !this._area)
            return E;
        const panelStyle = {
            opacity: 1,
            backgroundImage: this._backgroundImage || 'none',
        };
        return x `
            <div
                class="panel"
                style=${o(panelStyle)}
                ?admin=${this._isAdminMode}
            >
                ${this._isTablet
            ? renderHeader(this._headerChips ?? [])
            : E}
                ${renderArea(this._areaName, this._areaPicture, this._areaChips, this._isPhone, this._isLandscape)}
                ${renderControls(this._controlTiles, this._controlColumns, this._isPhone)}
                ${this._isPhone && this._isLandscape ? E : renderFooter()}
            </div>
        `;
    }
    updated(changedProps) {
        super.updated(changedProps);
        if (changedProps.has('hass') && this.hass) {
            this._deviceRefreshState = deviceRefresh(this.hass, this._deviceRefreshState);
            this._deviceRebootState = deviceReboot(this.hass, this._deviceRebootState);
            this._updateContent();
        }
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        if (this._timeIntervalId) {
            clearInterval(this._timeIntervalId);
            this._timeIntervalId = undefined;
        }
        if (this._dashboardTimer) {
            clearTimeout(this._dashboardTimer);
            this._dashboardTimer = undefined;
        }
        window.removeEventListener('resize', this._boundHandleDeviceChanges);
        window.removeEventListener('orientationchange', this._boundHandleDeviceChanges);
        window.removeEventListener('touchstart', this._boundStartDashboardTimer);
    }
    _loadContent() {
        if (!this._config || !this.hass)
            return;
        if (!this._headerChips)
            this._loadHeaderChips();
        this._areaObj = this._area ? this.hass.areas[this._area] : undefined;
        this._areaName = this._config.name ?? this._areaObj?.name ?? 'Unknown';
        this._areaPicture = this._config.picture ?? `${this._area}.png`;
        this._areaChips = createElements(this._config.area_chips || [], this.hass);
        const { controlTiles, controlColumns } = loadControlTiles(this._config.tiles ?? [], this.hass, this._isTablet);
        this._controlTiles = controlTiles;
        this._controlColumns = controlColumns;
    }
    async _loadHeaderChips() {
        if (!this._config || !this.hass)
            return;
        if (!window.smartqasa.chipsConfig) {
            const yamlFilePath = '/local/smartqasa/custom/chips.yaml';
            const chipsConfig = await loadYamlAsJson(yamlFilePath);
            window.smartqasa.chipsConfig = chipsConfig;
        }
        const chipsConfig = this._config.header_chips?.length
            ? this._config.header_chips
            : (window.smartqasa.chipsConfig ?? []);
        this._headerChips = createElements(chipsConfig, this.hass) || [];
    }
    _updateContent() {
        requestAnimationFrame(() => {
            const updateHassForCards = (cards) => {
                for (const card of cards) {
                    if (card.hass !== this.hass)
                        card.hass = this.hass;
                }
            };
            [this._headerChips, this._areaChips, ...this._controlTiles].forEach((group) => group?.length && updateHassForCards(group));
        });
    }
    _handleDeviceChanges() {
        const type = getDeviceType() ?? 'desktop';
        this._isPhone = type === 'phone';
        this._isTablet = type === 'tablet';
        const orientation = getDeviceOrientation() ?? 'landscape';
        this._isPortrait = orientation === 'portrait';
        this._isLandscape = orientation === 'landscape';
    }
    _handleBackgroundChange() {
        if (!this.hass)
            return;
        const mode = this.hass.themes.darkMode ? 'dark' : 'light';
        const style = this.hass.states['input_select.dashboard_background']?.state?.toLowerCase() || 'default';
        if (this._themeMode === mode && this._themeStyle === style)
            return;
        const baseUrl = new URL(location.href).origin;
        const imagePath = style === 'custom'
            ? 'local/smartqasa/custom/backgrounds'
            : `local/smartqasa/media/backgrounds/${style}`;
        this._backgroundImage = `url(${baseUrl}/${imagePath}/${mode}.jpg)`;
        this._themeMode = mode;
        this._themeStyle = style;
    }
    _startDashboardTimer() {
        clearTimeout(this._dashboardTimer);
        const delay = 5 * 60 * 1000;
        this._dashboardTimer = setTimeout(() => this._resetDashboard(), delay);
    }
    /*
    private _handleRefreshDashboard(): void {
        const state =
            this.hass?.states['input_button.refresh_dashboards']?.state;

        if (this._refreshDashboardState === undefined) {
            this._refreshDashboardState = state;
            return;
        }

        if (this._refreshDashboardState === state) return;

        this._refreshDashboardState = state;

        if (window.fully) {
            executeFullyAction('restartApp');
        } else {
            window.browser_mod?.service('refresh');
        }
    }

    private _handleRebootDevice(): void {
        if (!window.fully || !this.hass) return;

        const state = this.hass.states['input_button.reboot_devices']?.state;
        if (this._rebootDeviceState === undefined) {
            this._rebootDeviceState = state;
            return;
        }

        if (this._rebootDeviceState === state) return;

        this._rebootDeviceState = state;
        executeFullyAction('reboot');
    }
    */
    _resetDashboard() {
        this._startDashboardTimer();
        const swiperContainer = this.shadowRoot?.querySelector('swiper-container');
        if (swiperContainer?.swiper?.activeIndex !== 0) {
            swiperContainer.swiper.slideTo(0);
            return;
        }
        const area = location.pathname.split('/').pop();
        if (area !== window.smartqasa.startArea) {
            navigateToArea(window.smartqasa.startArea);
        }
    }
};
__decorate([
    n({ attribute: false })
], PanelCard.prototype, "hass", void 0);
__decorate([
    r()
], PanelCard.prototype, "_config", void 0);
__decorate([
    r()
], PanelCard.prototype, "_isAdminMode", void 0);
__decorate([
    r()
], PanelCard.prototype, "_isPhone", void 0);
__decorate([
    r()
], PanelCard.prototype, "_isTablet", void 0);
__decorate([
    r()
], PanelCard.prototype, "_isPortrait", void 0);
__decorate([
    r()
], PanelCard.prototype, "_isLandscape", void 0);
PanelCard = __decorate([
    t('smartqasa-panel-card')
], PanelCard);

export { PanelCard };
